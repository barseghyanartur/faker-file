faker-file
**********

**Create files with fake data**. In many formats. With no efforts.

[image: PyPI Version][image][image: Supported Python
versions][image][image: Build Status][image][image: Documentation
Status][image][image: llms.txt - documentation for LLMs][image][image:
MIT][image][image: Coverage][image]


Prerequisites
=============

All of core dependencies of this package are *MIT* licensed. Most of
optional dependencies of this package are *MIT* licensed, while a few
are *BSD*-, *Apache 2*-, *GPL* or *HPND* licensed.

All licenses are mentioned below between the brackets.

* Core package requires Python 3.9, 3.10, 3.11 or 3.12.

* Faker (*MIT*) is the only required dependency.

* Django (*BSD*) integration with factory_boy (*MIT*) has been tested
  with "Django" starting from version 2.2 to 4.2 (although only
  maintained versions of Django are currently being tested against).

* "BMP", "GIF" and "TIFF" file support requires either just
  >>`Pillow`_<< (*HPND*), or a combination of WeasyPrint (*BSD*),
  pdf2image (*MIT*), >>`Pillow`_<< (*HPND*) and poppler (*GPLv2*).

* "DOCX" file support requires python-docx (*MIT*).

* "EPUB" file support requires xml2epub (*MIT*) and Jinja2 (*BSD*).

* "ICO", "JPEG", "PNG", "SVG" and "WEBP" files support requires either
  just >>`Pillow`_<< (*HPND*), or a combination of imgkit (*MIT*) and
  >>`wkhtmltopdf`_<< (*LGPLv3*).

* "MP3" file support requires gTTS (*MIT*) or edge-tts (*GPLv3*).

* "PDF" file support requires either >>`Pillow`_<< (*HPND*), or a
  combination of pdfkit (*MIT*) and >>`wkhtmltopdf`_<< (*LGPLv3*), or
  reportlab (*BSD*).

* "PPTX" file support requires python-pptx (*MIT*).

* "ODP" and "ODT" file support requires odfpy (*Apache 2*).

* "ODS" file support requires tablib (*MIT*) and odfpy (*Apache 2*).

* "XLSX" file support requires tablib (*MIT*) and openpyxl (*MIT*).

* "PathyFileSystemStorage" storage support requires >>`pathy`_<<
  (*Apache 2*).

* "AWSS3Storage" storage support requires >>`pathy`_<< (*Apache 2*)
  and boto3 (*Apache 2*).

* "AzureCloudStorage" storage support requires >>`pathy`_<< (*Apache
  2*) and azure-storage-blob (*MIT*).

* "GoogleCloudStorage" storage support requires >>`pathy`_<< (*Apache
  2*) and google-cloud-storage (*Apache 2*).

* "SFTPStorage" storage support requires paramiko (*LGLPv2.1*).

* "AugmentFileFromDirProvider" provider requires either a combination
  of >>`textaugment`_<< (*MIT*) and nltk (*Apache 2*) or a combination
  of nlpaug (*MIT*), PyTorch (*BSD*), transformers (*Apache 2*), numpy
  (*BSD*), pandas (*BSD*), tika (*Apache 2*) and Apache Tika (*Apache
  2*).


Documentation
=============

* Documentation is available on Read the Docs.

* For bootstrapping check the Quick start.

* For various ready to use code examples see the Recipes.

* For tips on "PDF" creation see Creating PDF.

* For tips on "DOCX" creation see Creating DOCX.

* For tips on "ODT" creation see Creating ODT.

* For tips on images creation see Creating images.

* For CLI options see the CLI.

* Read the Methodology.

* For guidelines on contributing check the Contributor guidelines.


Online demos and related projects
=================================

Check the demo(s) and related projects below:

* REST API demo (based on faker-file-api REST API)

* UI frontend demo (based on faker-file-ui UI frontend)

* WASM frontend demo (based on faker-file-wasm WASM frontend)

* faker-file-qt GUI application (based on PyQT5).


Installation
============


Latest stable version from PyPI
-------------------------------

**WIth all dependencies**

   pip install faker-file'[all]'

**Only core**

   pip install faker-file

**With most common dependencies**

*Everything, except ML libraries which are required for data
augmentation only*

   pip install faker-file'[common]'

**With DOCX support**

   pip install faker-file'[docx]'

**With EPUB support**

   pip install faker-file'[epub]'

**With images support**

   pip install faker-file'[images]'

**With PDF support**

   pip install faker-file'[pdf]'

**With MP3 support**

   pip install faker-file'[mp3]'

**With XLSX support**

   pip install faker-file'[xlsx]'

**With ODS support**

   pip install faker-file'[ods]'

**With ODT support**

   pip install faker-file'[odt]'

**With data augmentation support**

   pip install faker-file'[data-augmentation]'

**With GoogleCloudStorage support**

   pip install faker-file'[gcs]'

**With AzureCloudStorage support**

   pip install faker-file'[azure]'

**With AWSS3Storage support**

   pip install faker-file'[s3]'


Or development version from GitHub
----------------------------------

   pip install https://github.com/barseghyanartur/faker-file/archive/main.tar.gz


Features
========


Supported file types
--------------------

* "BIN"

* "BMP"

* "CSV"

* "DOCX"

* "EML"

* "EPUB"

* "ICO"

* "GIF"

* "JPEG"

* "JSON"

* "MP3"

* "ODS"

* "ODT"

* "ODP"

* "PDF"

* "PNG"

* "RTF"

* "PPTX"

* "SVG"

* "TAR"

* "TIFF"

* "TXT"

* "WEBP"

* "XLSX"

* "XML"

* "ZIP"

For all image formats ("BMP", "ICO", "GIF", "JPEG", "PNG", "SVG",
"TIFF" and "WEBP") and "PDF", there are both graphic-only and mixed-
content file providers (that also have text-to-image capabilities).


Additional providers
--------------------

* "AugmentFileFromDirProvider": Make an augmented copy of randomly
  picked file from given directory. The following types are supported
  : "DOCX", "EML", "EPUB", "ODT",  "PDF", "RTF" and "TXT".

* "AugmentRandomImageFromDirProvider": Augment a random image file
  from given directory. The following types are supported : "BMP",
  "GIF", "JPEG", "PNG",  "TIFF" and "WEBP".

* "AugmentImageFromPathProvider": Augment an image file from given
  path. Supported file types are the same as for
  "AugmentRandomImageFromDirProvider" provider.

* "GenericFileProvider": Create files in any format from raw bytes or
  a predefined template.

* "RandomFileFromDirProvider": Pick a random file from given
  directory.

* "FileFromPathProvider": File from given path.


Supported file storages
-----------------------

* Native file system storage

* AWS S3 storage

* Azure Cloud Storage

* Google Cloud Storage

* SFTP storage


Usage examples
==============


With "Faker"
------------

**Recommended way**

   from faker import Faker
   # Import the file provider we want to use
   from faker_file.providers.txt_file import TxtFileProvider

   FAKER = Faker()  # Initialise Faker instance
   FAKER.add_provider(TxtFileProvider)  # Register the TXT file provider

   file = FAKER.txt_file()  # Generate a TXT file

   # Meta-data is stored inside a ``data`` attribute (``dict``).
   # The following line would produce something like /tmp/tmp/tmphzzb8mot.txt
   print(file.data["filename"])
   # The following line would produce a text generated by Faker, used as
   # the content of the generated file.
   print(file.data["content"])

Note:

  Note, that in this case "file" value is a "StringValue" instance,
  which inherits from "str" but contains meta-data such as absolute
  path to the generated file, and text used to generate the file,
  stored in "filename" and "content" keys of the "data" attribute
  respectively. See Meta-data for more information.

If you just need "bytes" back (instead of creating the file), provide
the "raw=True" argument (works with all provider classes and inner
functions):

   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider

   FAKER = Faker()
   FAKER.add_provider(TxtFileProvider)

   raw = FAKER.txt_file(raw=True)

Note:

  Note, that in this case "file" value is a "BytesValue" instance,
  which inherits from "bytes" but contains meta-data such as absolute
  path to the generated file, and text used to generate the file,
  stored in "filename" and "content" keys of the "data" attribute
  respectively. See Meta-data for more information.

**But this works too**

   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider

   FAKER = Faker()

   file = TxtFileProvider(FAKER).txt_file()

If you just need "bytes" back:

   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider

   FAKER = Faker()

   raw = TxtFileProvider(FAKER).txt_file(raw=True)


With "factory_boy"
------------------

*Filename: upload/models.py*

   from django.db import models

   class Upload(models.Model):

       # ...
       file = models.FileField()

       class Meta:
           app_label = "upload"

*Filename: upload/factories.py*

Note, that when using "faker-file" with "Django" and native file
system storages, you need to pass your "MEDIA_ROOT" setting as
"root_path" value to the chosen file storage as show below.

   import factory
   from django.conf import settings
   from factory import Faker
   from factory.django import DjangoModelFactory
   from faker_file.providers.docx_file import DocxFileProvider
   from faker_file.storages.filesystem import FileSystemStorage

   from upload.models import Upload

   FS_STORAGE = FileSystemStorage(
       root_path=settings.MEDIA_ROOT,
       rel_path="tmp"
   )
   factory.Faker.add_provider(DocxFileProvider)

   class UploadFactory(DjangoModelFactory):

       # ...
       file = Faker("docx_file", storage=FS_STORAGE)

       class Meta:
           model = Upload


Meta-data
=========

The return value of any file provider file generator function is
either "StringValue" or "BytesValue", which inherit from "str" and
"bytes" respectively.

Both "StringValue" and "BytesValue" instances have a meta data
attribute named "data" (type "dict"). Various file providers use
"data" to store meta-data, such as "filename" (absolute path to the
generated file; valid for all file providers), or "content" (text used
when generating the file; valid for most file providers, except
"FileFromPathProvider", "RandomFileFromDirProvider", "TarFileProvider"
and "ZipFileProvider").

All file providers store an absolute path to the generated file in
"filename" key of the "data" attribute and instance of the storage
used in "storage" key. See the table below.

+-------------+-------------------------------------------------------------------+
| Key name    | File provider                                                     |
|=============|===================================================================|
| filename    | all                                                               |
+-------------+-------------------------------------------------------------------+
| storage     | all                                                               |
+-------------+-------------------------------------------------------------------+
| content     | all except FileFromPathProvider, RandomFileFromDirProvider,       |
|             | TarFileProvider, ZipFileProvider and all graphic file providers   |
|             | such as GraphicBmpFileProvider, GraphicGifFileProvider,           |
|             | GraphicIcoFileProvider, GraphicJpegFileProvider,                  |
|             | GraphicPdfFileProvider, GraphicPngFileProvider,                   |
|             | GraphicTiffFileProvider and GraphicWebpFileProvider               |
+-------------+-------------------------------------------------------------------+
| inner       | only EmlFileProvider, TarFileProvider and ZipFileProvider         |
+-------------+-------------------------------------------------------------------+


File storages
=============

All file operations are delegated to a separate abstraction layer of
storages.

The following storages are implemented:

* "FileSystemStorage": Does not have additional requirements.

* "PathyFileSystemStorage": Requires >>`pathy`_<<.

* "AzureCloudStorage": Requires >>`pathy`_<< and *Azure* related
  dependencies.

* "GoogleCloudStorage": Requires >>`pathy`_<< and *Google Cloud*
  related dependencies.

* "AWSS3Storage": Requires >>`pathy`_<< and *AWS S3* related
  dependencies.

* "SFTPStorage": Requires paramiko and related dependencies.


Usage example with storages
---------------------------


*FileSystemStorage* example
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Native file system storage. Does not have dependencies.

* "root_path": Path to the root directory. Given the example of
  Django, this would be the path to the "MEDIA_ROOT" directory. It's
  important to know, that "root_path" will not be embedded into the
  string representation of the file. Only "rel_path" will.

* "rel_path": Relative path from the root directory. Given the example
  of Django, this would be the rest of the path to the file.

   import tempfile
   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider
   from faker_file.storages.filesystem import FileSystemStorage

   FS_STORAGE = FileSystemStorage(
       root_path=tempfile.gettempdir(),  # Use settings.MEDIA_ROOT for Django
       rel_path="tmp",
   )

   FAKER = Faker()

   file = TxtFileProvider(FAKER).txt_file(storage=FS_STORAGE)

   FS_STORAGE.exists(file)


*PathyFileSystemStorage* example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Native file system storage. Requires "pathy".

   import tempfile
   from pathy import use_fs
   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider
   from faker_file.storages.cloud import PathyFileSystemStorage

   use_fs(tempfile.gettempdir())
   PATHY_FS_STORAGE = PathyFileSystemStorage(
       bucket_name="bucket_name",
       root_path="tmp",
       rel_path="sub-tmp",
   )

   FAKER = Faker()

   file = TxtFileProvider(FAKER).txt_file(storage=PATHY_FS_STORAGE)

   PATHY_FS_STORAGE.exists(file)


*AWSS3Storage* example
~~~~~~~~~~~~~~~~~~~~~~

AWS S3 storage. Requires "pathy" and "boto3".

   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider
   from faker_file.storages.aws_s3 import AWSS3Storage

   S3_STORAGE = AWSS3Storage(
       bucket_name="bucket_name",
       root_path="tmp",  # Optional
       rel_path="sub-tmp",  # Optional
       # Credentials are optional too. If your AWS credentials are properly
       # set in the ~/.aws/credentials, you don't need to send them
       # explicitly.
       credentials={
           "key_id": "YOUR KEY ID",
           "key_secret": "YOUR KEY SECRET"
       },
   )

   FAKER = Faker()

   file = TxtFileProvider(FAKER).txt_file(storage=S3_STORAGE)

   assert S3_STORAGE.exists(file)


Testing
=======

Simply type:

   pytest -vrx

Or use tox:

   tox

Or use tox to check specific env:

   tox -e py310-django41


Writing documentation
=====================

Keep the following hierarchy.

   =====
   title
   =====

   header
   ======

   sub-header
   ----------

   sub-sub-header
   ~~~~~~~~~~~~~~

   sub-sub-sub-header
   ^^^^^^^^^^^^^^^^^^

   sub-sub-sub-sub-header
   ++++++++++++++++++++++

   sub-sub-sub-sub-sub-header
   **************************


License
=======

MIT


Support
=======

For security issues contact me at the e-mail given in the Author
section.

For overall issues, go to GitHub.


Author
======

Artur Barseghyan <artur.barseghyan@gmail.com>


Citation
========

Please, use the following entry when citing >>`faker-file`_<< in your
research:

   @software{faker-file,
     author = {Artur Barseghyan},
     title = {faker-file: Create files with fake data. In many formats. With no efforts.},
     year = {2022-2025},
     publisher = {GitHub},
     journal = {GitHub repository},
     howpublished = {https://github.com/barseghyanartur/faker-file},
   }

======================================================================


Recipes
=======


When using with "Faker"
-----------------------

When using with "Faker", there are two ways of using the providers.


Imports and initializations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Recommended way**

   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider

   FAKER = Faker()
   FAKER.add_provider(TxtFileProvider)

   # Usage example
   txt_file = FAKER.txt_file(content="Lorem ipsum")

*See the full example* "here"

**But this works too**

   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider

   FAKER = Faker()

   # Usage example
   txt_file = TxtFileProvider(FAKER).txt_file(content="Lorem ipsum")

*See the full example* "here"

Throughout documentation we will be mixing these approaches.


Create a TXT file with static content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Content of the file is "Lorem ipsum".

   txt_file = FAKER.txt_file(content="Lorem ipsum")

*See the full example* "here"


Create a DOCX file with dynamically generated content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Content is generated dynamically.

* Content is limited to 1024 chars.

* Wrap lines after 80 chars.

* Prefix the filename with "zzz".

   docx_file = FAKER.docx_file(
       prefix="zzz",
       max_nb_chars=1_024,
       wrap_chars_after=80,
   )

*See the full example* "here"


Create a ZIP file consisting of TXT files with static content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 5 TXT files in the ZIP archive (default value is 5).

* Content of all files is "Lorem ipsum".

   zip_file = FAKER.zip_file(
       options={"create_inner_file_args": {"content": "Lorem ipsum"}}
   )

*See the full example* "here"


Create a ZIP file consisting of 3 DOCX files with dynamically generated content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 3 DOCX files in the ZIP archive.

* Content is generated dynamically.

* Content is limited to 1024 chars.

* Prefix the filenames in archive with "xxx_".

* Prefix the filename of the archive itself with "zzz".

* Inside the ZIP, put all files in directory "yyy".

   from faker_file.providers.helpers.inner import create_inner_docx_file

   zip_file = FAKER.zip_file(
       prefix="zzz",
       options={
           "count": 3,
           "create_inner_file_func": create_inner_docx_file,
           "create_inner_file_args": {
               "prefix": "xxx_",
               "max_nb_chars": 1_024,
           },
           "directory": "yyy",
       },
   )

*See the full example* "here"


Create a ZIP file of 9 DOCX files with content generated from template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 9 DOCX files in the ZIP archive.

* Content is generated dynamically from given template.

   from faker_file.providers.helpers.inner import create_inner_docx_file

   TEMPLATE = "Hey {{name}},\n{{text}},\nBest regards\n{{name}}"

   zip_file = FAKER.zip_file(
       options={
           "count": 9,
           "create_inner_file_func": create_inner_docx_file,
           "create_inner_file_args": {
               "content": TEMPLATE,
           },
       }
   )

*See the full example* "here"


Create a nested ZIP file
~~~~~~~~~~~~~~~~~~~~~~~~

Create a ZIP file which contains 5 ZIP files which contain 5 ZIP files
which contain 5 DOCX files.

* 5 ZIP files in the ZIP archive.

* Content is generated dynamically.

* Prefix the filenames in archive with "nested_level_1_".

* Prefix the filename of the archive itself with "nested_level_0_".

* Each of the ZIP files inside the ZIP file in their turn contains 5
  other ZIP files, prefixed with "nested_level_2_", which in their
  turn contain 5 DOCX files.

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_zip_file,
   )

   zip_file = FAKER.zip_file(
       prefix="nested_level_0_",
       options={
           "create_inner_file_func": create_inner_zip_file,
           "create_inner_file_args": {
               "prefix": "nested_level_1_",
               "options": {
                   "create_inner_file_func": create_inner_zip_file,
                   "create_inner_file_args": {
                       "prefix": "nested_level_2_",
                       "options": {
                           "create_inner_file_func": create_inner_docx_file,
                       },
                   },
               },
           },
       },
   )

*See the full example* "here"


Create a ZIP file with variety of different file types within
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 50 files in the ZIP archive (limited to DOCX, EPUB and TXT types).

* Content is generated dynamically.

* Prefix the filename of the archive itself with "zzz_archive_".

* Inside the ZIP, put all files in directory "zzz".

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_epub_file,
       create_inner_txt_file,
       fuzzy_choice_create_inner_file,
   )
   from faker_file.storages.filesystem import FileSystemStorage

   STORAGE = FileSystemStorage()

   kwargs = {"storage": STORAGE, "generator": FAKER}

   zip_file = FAKER.zip_file(
       prefix="zzz_archive_",
       options={
           "count": 50,
           "create_inner_file_func": fuzzy_choice_create_inner_file,
           "create_inner_file_args": {
               "func_choices": [
                   (create_inner_docx_file, kwargs),
                   (create_inner_epub_file, kwargs),
                   (create_inner_txt_file, kwargs),
               ],
           },
           "directory": "zzz",
       },
   )

*See the full example* "here"


Another way to create a ZIP file with variety of different file types within
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 3 files in the ZIP archive (1 DOCX, and 2 XML types).

* Content is generated dynamically.

* Filename of the archive itself is "alice-looking-through-the-
  glass.zip".

* Files inside the archive have fixed name (passed with "basename"
  argument).

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_xml_file,
       list_create_inner_file,
   )

   zip_file = FAKER.zip_file(
       basename="alice-looking-through-the-glass",
       options={
           "create_inner_file_func": list_create_inner_file,
           "create_inner_file_args": {
               "func_list": [
                   (create_inner_docx_file, {"basename": "doc"}),
                   (create_inner_xml_file, {"basename": "doc_metadata"}),
                   (create_inner_xml_file, {"basename": "doc_isbn"}),
               ],
           },
       },
   )

*See the full example* "here"

Note, that "count" argument (not shown in the example, but commonly
accepted by inner functions) will be simply ignored here.


Create an EML file consisting of TXT files with static content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 5 TXT files in the EML email (default value is 5).

* Content of all files is "Lorem ipsum".

   from faker_file.providers.eml_file import EmlFileProvider

   FAKER.add_provider(EmlFileProvider)

   eml_file = FAKER.eml_file(
       options={"create_inner_file_args": {"content": "Lorem ipsum"}}
   )

*See the full example* "here"


Create a EML file consisting of 3 DOCX files with dynamically generated content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 3 DOCX files in the EML email.

* Content is generated dynamically.

* Content is limited to 1024 chars.

* Prefix the filenames in email with "xxx_".

* Prefix the filename of the email itself with "zzz".

   from faker_file.providers.helpers.inner import create_inner_docx_file

   eml_file = FAKER.eml_file(
       prefix="zzz",
       options={
           "count": 3,
           "create_inner_file_func": create_inner_docx_file,
           "create_inner_file_args": {
               "prefix": "xxx_",
               "max_nb_chars": 1_024,
           },
       },
   )

*See the full example* "here"


Create a nested EML file
~~~~~~~~~~~~~~~~~~~~~~~~

Create a EML file which contains 5 EML files which contain 5 EML files
which contain 5 DOCX files.

* 5 EML files in the EML file.

* Content is generated dynamically.

* Prefix the filenames in EML email with "nested_level_1_".

* Prefix the filename of the EML email itself with "nested_level_0_".

* Each of the EML files inside the EML file in their turn contains 5
  other EML files, prefixed with "nested_level_2_", which in their
  turn contain 5 DOCX files.

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_eml_file,
   )

   eml_file = FAKER.eml_file(
       prefix="nested_level_0_",
       options={
           "create_inner_file_func": create_inner_eml_file,
           "create_inner_file_args": {
               "prefix": "nested_level_1_",
               "options": {
                   "create_inner_file_func": create_inner_eml_file,
                   "create_inner_file_args": {
                       "prefix": "nested_level_2_",
                       "options": {
                           "create_inner_file_func": create_inner_docx_file,
                       },
                   },
               },
           },
       },
   )

*See the full example* "here"


Create an EML file with variety of different file types within
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 10 files in the EML file (limited to DOCX, EPUB and TXT types).

* Content is generated dynamically.

* Prefix the filename of the EML itself with "zzz".

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_epub_file,
       create_inner_txt_file,
       fuzzy_choice_create_inner_file,
   )

   eml_file = FAKER.eml_file(
       prefix="zzz",
       options={
           "count": 10,
           "create_inner_file_func": fuzzy_choice_create_inner_file,
           "create_inner_file_args": {
               "func_choices": [
                   (create_inner_docx_file, kwargs),
                   (create_inner_epub_file, kwargs),
                   (create_inner_txt_file, kwargs),
               ],
           },
       },
   )

*See the full example* "here"


Create an EML file "Content-Transfer-Encoding" set to "7bit"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 10 files in the EML file (limited to DOCX, EPUB and TXT types).

* Content is generated dynamically.

* Set the "Content-Transfer-Encoding" to "7bit".

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_epub_file,
       create_inner_txt_file,
       fuzzy_choice_create_inner_file,
   )

   eml_file = FAKER.eml_file(
       cte_type="7bit",
       options={
           "count": 10,
           "create_inner_file_func": fuzzy_choice_create_inner_file,
           "create_inner_file_args": {
               "func_choices": [
                   (create_inner_docx_file, kwargs),
                   (create_inner_epub_file, kwargs),
                   (create_inner_txt_file, kwargs),
               ],
           },
       },
   )

*See the full example* "here"


Create a PDF file with predefined template containing dynamic fixtures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Content template is predefined and contains dynamic fixtures.

* Wrap lines after 80 chars.

   from faker_file.providers.pdf_file import PdfFileProvider

   FAKER.add_provider(PdfFileProvider)

   TEMPLATE = """
   {{date}} {{city}}, {{country}}

   Hello {{name}},

   {{text}} {{text}} {{text}}

   {{text}} {{text}} {{text}}

   {{text}} {{text}} {{text}}

   Address: {{address}}

   Best regards,

   {{name}}
   {{address}}
   {{phone_number}}
   """

   pdf_file = FAKER.pdf_file(content=TEMPLATE, wrap_chars_after=80)

*See the full example* "here"


Create a DOCX file with table and image using "DynamicTemplate"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When pre-defined templating and dynamic fixtures are not enough and
full control is needed, you can use "DynamicTemplate" wrapper. It
takes a list of content modifiers (tuples): "(func: Callable, kwargs:
dict)". Each callable should accept the following arguments:

* *provider*: Faker "Generator" instance or "Faker" instance.

* *document*: Document instance. Implementation specific.

* *data*: Dictionary. Used primarily for observability.

* *counter*: Integer. Index number of the content modifier.

* ***kwargs*: Dictionary. Useful to pass implementation-specific
  arguments.

The following example shows how to generate a DOCX file with
paragraph, table and image.

   from faker_file.base import DynamicTemplate
   from faker_file.contrib.docx_file import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create a DOCX file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   docx_file = FAKER.docx_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       )
   )

*See the full example* "here"


Create a ODT file with table and image using "DynamicTemplate"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Similarly to previous section, the following example shows how to
generate an ODT file with table and image.

   from faker_file.contrib.odt_file import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )
   from faker_file.providers.odt_file import OdtFileProvider

   FAKER.add_provider(OdtFileProvider)  # Register OdtFileProvider

   # Create a ODT file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   odt_file = FAKER.odt_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       )
   )

*See the full example* "here"


Create a PDF using *reportlab* generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   from faker_file.providers.pdf_file.generators.reportlab_generator import (
       ReportlabPdfGenerator,
   )

   pdf_file = FAKER.pdf_file(pdf_generator_cls=ReportlabPdfGenerator)

*See the full example* "here"


Create a PDF using *pdfkit* generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note, that at the moment, "pdfkit" is the default generator. However,
you could set it explicitly as follows:

   from faker_file.providers.pdf_file.generators.pdfkit_generator import (
       PdfkitPdfGenerator,
   )

   pdf_file = FAKER.pdf_file(pdf_generator_cls=PdfkitPdfGenerator)

*See the full example* "here"


Create a graphic PDF file using *Pillow*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Graphic PDF file does not contain text. Don't use it when you need
text based content. However, sometimes you just need a valid file in
PDF format, without caring much about the content. That's where a
GraphicPdfFileProvider comes to rescue:

   from faker_file.providers.pdf_file import GraphicPdfFileProvider

   FAKER.add_provider(GraphicPdfFileProvider)

   pdf_file = FAKER.graphic_pdf_file()

*See the full example* "here"

The generated file will contain a random graphic (consisting of lines
and shapes of different colours). One of the most useful arguments
supported is "size".

   pdf_file = FAKER.graphic_pdf_file(size=(800, 800))

*See the full example* "here"


Graphic providers
~~~~~~~~~~~~~~~~~

Graphic file providers does not contain text. Don't use it when you
need text based content. However, sometimes you just need a valid
image file with graphics of a certain size. That's where graphic file
providers help.

Supported files formats are: *BMP*, *GIF*, *ICO*, *JPEG*, *PDF*,
*PNG*, *SVG* *TIFF* and *WEBP*.


Create an ICO file
""""""""""""""""""

   from faker_file.providers.ico_file import GraphicIcoFileProvider

   FAKER.add_provider(GraphicIcoFileProvider)

   ico_file = FAKER.graphic_ico_file(size=(800, 800))

*See the full example* "here"


Create a JPEG file
""""""""""""""""""

   from faker_file.providers.jpeg_file import GraphicJpegFileProvider

   FAKER.add_provider(GraphicJpegFileProvider)

   jpeg_file = FAKER.graphic_jpeg_file(size=(800, 800))

*See the full example* "here"


Create a PNG file
"""""""""""""""""

   from faker_file.providers.png_file import GraphicPngFileProvider

   FAKER.add_provider(GraphicPngFileProvider)

   png_file = FAKER.graphic_png_file(size=(800, 800))

*See the full example* "here"


Create a WEBP file
""""""""""""""""""

   from faker_file.providers.webp_file import GraphicWebpFileProvider

   FAKER.add_provider(GraphicWebpFileProvider)

   webp_file = FAKER.graphic_webp_file(size=(800, 800))

*See the full example* "here"


Create a MP3 file
~~~~~~~~~~~~~~~~~

   from faker_file.providers.mp3_file import Mp3FileProvider

   FAKER.add_provider(Mp3FileProvider)

   mp3_file = FAKER.mp3_file()

*See the full example* "here"


Create a MP3 file by explicitly specifying MP3 generator class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Google Text-to-Speech
"""""""""""""""""""""

   from faker_file.providers.mp3_file.generators.gtts_generator import (
       GttsMp3Generator,
   )

   mp3_file = FAKER.mp3_file(mp3_generator_cls=GttsMp3Generator)

*See the full example* "here"

======================================================================

You can tune arguments too:

   mp3_file = FAKER.mp3_file(
       mp3_generator_cls=GttsMp3Generator,
       mp3_generator_kwargs={
           "lang": "en",
           "tld": "co.uk",
       },
   )

*See the full example* "here"

Refer to https://gtts.readthedocs.io/en/latest/module.html#languages-
gtts-lang for list of accepted values for "lang" argument.

Refer to https://gtts.readthedocs.io/en/latest/module.html#localized-
accents for list of accepted values for "tld" argument.


Microsoft Edge Text-to-Speech
"""""""""""""""""""""""""""""

   from faker_file.providers.mp3_file.generators.edge_tts_generator import (
       EdgeTtsMp3Generator,
   )

   mp3_file = FAKER.mp3_file(mp3_generator_cls=EdgeTtsMp3Generator)

*See the full example* "here"

======================================================================

You can tune arguments too:

   mp3_file = FAKER.mp3_file(
       mp3_generator_cls=EdgeTtsMp3Generator,
       mp3_generator_kwargs={
           "voice": "en-GB-LibbyNeural",
       },
   )

*See the full example* "here"

Run "edge-tts -l" from terminal for list of available voices.


Create a MP3 file with custom MP3 generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Default MP3 generator class is "GttsMp3Generator" which uses Google
Text-to-Speech services to generate an MP3 file from given or randomly
generated text. It does not require additional services to run and the
only dependency here is the "gtts" package. You can however implement
your own custom MP3 generator class and pass it to te "mp3_file"
method in "mp3_generator_cls" argument instead of the default
"GttsMp3Generator". Read about quotas of Google Text-to-Speech
services here.

Usage with custom MP3 generator class.

   from faker_file.providers.base.mp3_generator import BaseMp3Generator
   from marytts import MaryTTS  # Imaginary `marytts` Python library

   # Define custom MP3 generator
   class MaryTtsMp3Generator(BaseMp3Generator):
       locale: str = "cmu-rms-hsmm"
       voice: str = "en_US"

       def handle_kwargs(self, **kwargs) -> None:
           # Since it's impossible to unify all TTS systems it's allowed
           # to pass arbitrary arguments to the `BaseMp3Generator`
           # constructor. Each implementation class contains its own
           # additional tuning arguments. Check the source code of the
           # implemented MP3 generators as an example.
           if "locale" in kwargs:
               self.locale = kwargs["locale"]
           if "voice" in kwargs:
               self.voice = kwargs["voice"]

       def generate(self) -> bytes:
           # Your implementation here. Note, that `self.content`
           # in this context is the text to make MP3 from.
           # `self.generator` would be the `Faker` or `Generator`
           # instance from which you could extract information on
           # active locale.
           # What comes below is pseudo implementation.
           mary_tts = MaryTTS(locale=self.locale, voice=self.voice)
           return mary_tts.synth_mp3(self.content)


   # Generate MP3 file from random text
   mp3_file = FAKER.mp3_file(
       mp3_generator_cls=MaryTtsMp3Generator,
   )

*See the full example* "here"

See exact implementation of marytts_mp3_generator in the examples.


Pick a random file from a directory given
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Create an exact copy of the randomly picked file under a different
  name.

* Prefix of the destination file would be "zzz".

* "source_dir_path" is the absolute path to the directory to pick
  files from.

   from faker_file.providers.random_file_from_dir import RandomFileFromDirProvider

   FAKER.add_provider(RandomFileFromDirProvider)

   # We assume that directory "/tmp/tmp/" exists and contains files.
   random_file = FAKER.random_file_from_dir(
       source_dir_path="/tmp/tmp/",
       prefix="zzz",
   )

*See the full example* "here"


File from path given
~~~~~~~~~~~~~~~~~~~~

* Create an exact copy of a file under a different name.

* Prefix of the destination file would be "zzz".

* "path" is the absolute path to the file to copy.

   from faker_file.providers.file_from_path import FileFromPathProvider

   FAKER.add_provider(FileFromPathProvider)

   # We assume that the file "/tmp/tmp/file.docx" exists.
   docx_file = FAKER.file_from_path(
       path="/tmp/tmp/file.docx",
       prefix="zzz",
   )

*See the full example* "here"


Generate a file of a certain size
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The only two file types for which it is easy to foresee the file size
are BIN and TXT. Note, that size of BIN files is always exact, while
for TXT it is approximate.


BIN
"""

   from faker_file.providers.bin_file import BinFileProvider

   FAKER.add_provider(BinFileProvider)

   bin_file = FAKER.bin_file(length=1024**2)  # 1 Mb
   bin_file = FAKER.bin_file(length=3 * 1024**2)  # 3 Mb
   bin_file = FAKER.bin_file(length=10 * 1024**2)  # 10 Mb

   bin_file = FAKER.bin_file(length=1024)  # 1 Kb
   bin_file = FAKER.bin_file(length=3 * 1024)  # 3 Kb
   bin_file = FAKER.bin_file(length=10 * 1024)  # 10 Kb

*See the full example* "here"


TXT
"""

   from faker_file.providers.txt_file import TxtFileProvider

   FAKER.add_provider(TxtFileProvider)

   txt_file = FAKER.txt_file(max_nb_chars=1024**2)  # 1 Mb
   txt_file = FAKER.txt_file(max_nb_chars=3 * 1024**2)  # 3 Mb
   txt_file = FAKER.txt_file(max_nb_chars=10 * 1024**2)  # 10 Mb

   txt_file = FAKER.txt_file(max_nb_chars=1024)  # 1 Kb
   txt_file = FAKER.txt_file(max_nb_chars=3 * 1024)  # 3 Kb
   txt_file = FAKER.txt_file(max_nb_chars=10 * 1024)  # 10 Kb

*See the full example* "here"


Generate a files using multiprocessing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Generate 10 DOCX files
""""""""""""""""""""""

* Use template.

* Generate 10 DOCX files.

   from multiprocessing import Pool
   from faker_file.providers.helpers.inner import create_inner_docx_file
   from faker_file.storages.filesystem import FileSystemStorage

   STORAGE = FileSystemStorage()

   # Document template
   TEMPLATE = "Hey {{name}},\n{{text}},\nBest regards\n{{name}}"

   with Pool(processes=2) as pool:
       for _ in range(10):  # Number of times we want to run our function
           pool.apply_async(
               create_inner_docx_file,
               # Apply async doesn't support kwargs. We have to pass all
               # arguments.
               [STORAGE, "mp", FAKER, None, None, TEMPLATE],
           )
       pool.close()
       pool.join()

*See the full example* "here"


Randomize the file format
"""""""""""""""""""""""""

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_epub_file,
       create_inner_pdf_file,
       create_inner_txt_file,
       fuzzy_choice_create_inner_file,
   )

   kwargs = {"storage": STORAGE, "generator": FAKER, "content": TEMPLATE}

   with Pool(processes=2) as pool:
       for _ in range(10):  # Number of times we want to run our function
           pool.apply_async(
               fuzzy_choice_create_inner_file,
               [
                   [
                       (create_inner_docx_file, kwargs),
                       (create_inner_epub_file, kwargs),
                       (create_inner_pdf_file, kwargs),
                       (create_inner_txt_file, kwargs),
                   ]
               ],
           )
       pool.close()
       pool.join()

*See the full example* "here"


Generating files from existing documents using NLP augmentation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

See the following example:

   from faker_file.providers.augment_file_from_dir import (
       AugmentFileFromDirProvider,
   )

   FAKER.add_provider(AugmentFileFromDirProvider)

   # We assume that directory "/tmp/tmp/" exists and contains
   # files of `DOCX`, `EML`, `EPUB`, `ODT`, `PDF`, `RTF` or `TXT`
   # formats.
   augmented_file = FAKER.augment_file_from_dir(
       source_dir_path="/tmp/tmp/",
   )

*See the full example* "here"

Generated file will resemble text of the original document, but will
not be the same. This is useful when you don't want to test on text
generated by "Faker", but rather something that makes more sense for
your use case, still want to ensure uniqueness of the documents.

The following file types are supported:

* "DOCX"

* "EML"

* "EPUB"

* "ODT"

* "PDF"

* "RTF"

* "TXT"

======================================================================

By default, all supported files are eligible for random selection. You
could however narrow that list by providing "extensions" argument:

   # We assume that directory "/tmp/tmp/" exists and contains
   # files of `DOCX` and `ODT` formats.
   augmented_file = FAKER.augment_file_from_dir(
       source_dir_path="/tmp/tmp/",
       extensions={"docx", "odt"},  # Pick only DOCX or ODT
   )

*See the full example* "here"

======================================================================

Actual augmentation of texts is delegated to an abstraction layer of
text augmenters. Currently, two augmenters are implemented. Default
one is based on >>`textaugment`_<< (which is in its' turn based on
nltk) is very lightweight and speedy, but produces less accurate
results. Another one is based on nlpaug, which is way more
sophisticated, but at the cost of speed.


nlpaug augmenter
~~~~~~~~~~~~~~~~

By default "bert-base-multilingual-cased" model is used, which is
pretrained on the top 104 languages with the largest Wikipedia using a
masked language modeling (MLM) objective. If you want to use a
different model, specify the proper identifier in the "model_path"
argument. Some well working options for "model_path" are:

* "bert-base-multilingual-cased"

* "bert-base-multilingual-uncased"

* "bert-base-cased"

* "bert-base-uncased"

* "bert-base-german-cased"

* "GroNLP/bert-base-dutch-cased"

   from faker_file.providers.augment_file_from_dir.augmenters import (
       nlpaug_augmenter,
   )

   # We assume that directory "/tmp/tmp/" exists and contains
   # files of `DOCX`, `EML`, `EPUB`, `ODT`, `PDF`, `RTF` or `TXT`
   # formats.
   augmented_file = FAKER.augment_file_from_dir(
       source_dir_path="/tmp/tmp/",
       text_augmenter_cls=nlpaug_augmenter.ContextualWordEmbeddingsAugmenter,
       text_augmenter_kwargs={
           "model_path": "bert-base-cased",
           "action": "substitute",  # or "insert"
       },
   )

*See the full example* "here"

Refer to "nlpaug" docs and check *Textual augmenters* examples.


textaugment augmenter
~~~~~~~~~~~~~~~~~~~~~

   from faker_file.providers.augment_file_from_dir.augmenters import (
       textaugment_augmenter,
   )

   # We assume that directory "/tmp/tmp/" exists and contains
   # files of `DOCX`, `EML`, `EPUB`, `ODT`, `PDF`, `RTF` or `TXT`
   # formats. Valid values for `action` are: "random_deletion",
   # "random_insertion", "random_swap" and "synonym_replacement" (default).
   augmented_file = FAKER.augment_file_from_dir(
       source_dir_path="/tmp/tmp/",
       text_augmenter_cls=textaugment_augmenter.EDATextaugmentAugmenter,
       text_augmenter_kwargs={
           "action": "synonym_replacement",
       },
   )

*See the full example* "here"


Using *raw=True* features in tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you pass "raw=True" argument to any provider or inner function,
instead of creating a file, you will get "bytes" back (or to be
totally correct, "bytes"-like object "BytesValue", which is basically
bytes enriched with meta-data). You could then use the "bytes" content
of the file to build a test payload as shown in the example test
below:

   class UploadTestCase(TestCase):
       """Upload test case."""

       def test_create_docx_upload(self) -> None:
           """Test create an Upload."""
           url = reverse("api:upload-list")

           raw = FAKER.docx_file(raw=True)
           test_file = BytesIO(raw)
           test_file.name = os.path.basename(raw.data["filename"])

           payload = {
               "name": FAKER.word(),
               "description": FAKER.paragraph(),
               "file": test_file,
           }

           response = self.client.post(url, payload, format="json")

           # Test if request is handled properly (HTTP 201)
           self.assertEqual(response.status_code, HTTP_201_CREATED)

           test_upload = Upload.objects.get(id=response.data["id"])

           # Test if the name is properly recorded
           self.assertEqual(str(test_upload.name), payload["name"])

           # Test if file name recorded properly
           self.assertEqual(str(test_upload.file.name), test_file.name)

*See the full example* "here"


Create a HTML file from predefined template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to generate a file in a format that is not (yet)
supported, you can try to use "GenericFileProvider". In the following
example, an HTML file is generated from a template.

   from faker_file.providers.generic_file import GenericFileProvider

   FAKER.add_provider(GenericFileProvider)

   generic_file = FAKER.generic_file(
       content="<html><body><p>{{text}}</p></body></html>",
       extension="html",
   )

*See the full example* "here"


Working with storages
~~~~~~~~~~~~~~~~~~~~~


AWS S3 storage
""""""""""""""

   from faker_file.storages.aws_s3 import AWSS3Storage

   AWS_S3_STORAGE = AWSS3Storage(
       bucket_name="your-bucket-name",
       root_path="",
       rel_path="",
   )

   txt_file = FAKER.txt_file(storage=AWS_S3_STORAGE)

*See the full example* "here"

======================================================================

Depending on the ORM or framework you're using, you might want to
tweak the "root_path" and "rel_path" values. Especially if you store
files in directories (like "your-bucket-name/path/to/the/file.ext").

For instance, if you use "Django" and "django-storages", and want to
store the files inside "/user/uploads" directory the following would
be correct:

   AWS_S3_STORAGE = AWSS3Storage(
       bucket_name="your-bucket-name",
       root_path="",
       rel_path="user/uploads",
   )

*See the full example* "here"


Google Cloud Storage
""""""""""""""""""""

   from faker_file.storages.google_cloud_storage import GoogleCloudStorage

   GC_STORAGE = GoogleCloudStorage(
       bucket_name="your-bucket-name",
       root_path="",
       rel_path="",
   )

   # txt_file = FAKER.txt_file(storage=GC_STORAGE)

*See the full example* "here"

======================================================================

Similarly to "AWSS3Storage", if you use "Django" and "django-
storages", and want to store the files inside "/user/uploads"
directory the following would be correct:

   GC_STORAGE = GoogleCloudStorage(
       bucket_name="your-bucket-name",
       root_path="",
       rel_path="user/uploads",
   )

*See the full example* "here"


SFTP storage
""""""""""""

   from faker_file.storages.sftp_storage import SFTPStorage

   SFTP_STORAGE = SFTPStorage(
       host="your-sftp-host.domain",
       port=22,
       username="your-sftp-username",
       password="your-sftp-password",
       root_path="/dir-name",
   )

   # txt_file = FAKER.txt_file(storage=SFTP_STORAGE)

*See the full example* "here"


When using with "Django" (and "factory_boy")
--------------------------------------------

When used with Django (to generate fake data with "factory_boy"
factories), the "root_path" argument of the correspondent file storage
shall be provided. Otherwise (although no errors will be triggered)
the generated files will reside outside the "MEDIA_ROOT" directory (by
default in "/tmp/" on Linux) and further operations with those files
through Django will cause "SuspiciousOperation" exception.

======================================================================


Basic example
~~~~~~~~~~~~~


Imaginary "Django" model
""""""""""""""""""""""""

   class Upload(models.Model):
       """Upload model."""

       name = models.CharField(max_length=255, unique=True)
       description = models.TextField(null=True, blank=True)

       # File
       file = models.FileField(null=True)

*See the full example* "here"


Correspondent "factory_boy" factory
"""""""""""""""""""""""""""""""""""

   from django.conf import settings
   from factory import Faker, Trait
   from factory.django import DjangoModelFactory

   # Import all providers we want to use
   from faker_file.providers.bin_file import BinFileProvider
   from faker_file.providers.csv_file import CsvFileProvider
   from faker_file.providers.docx_file import DocxFileProvider
   from faker_file.providers.eml_file import EmlFileProvider
   from faker_file.providers.epub_file import EpubFileProvider
   from faker_file.providers.ico_file import IcoFileProvider
   from faker_file.providers.jpeg_file import JpegFileProvider
   from faker_file.providers.mp3_file import Mp3FileProvider
   from faker_file.providers.ods_file import OdsFileProvider
   from faker_file.providers.odt_file import OdtFileProvider
   from faker_file.providers.pdf_file import PdfFileProvider
   from faker_file.providers.png_file import PngFileProvider
   from faker_file.providers.pptx_file import PptxFileProvider
   from faker_file.providers.rtf_file import RtfFileProvider
   from faker_file.providers.svg_file import SvgFileProvider
   from faker_file.providers.txt_file import TxtFileProvider
   from faker_file.providers.webp_file import WebpFileProvider
   from faker_file.providers.xlsx_file import XlsxFileProvider
   from faker_file.providers.zip_file import ZipFileProvider

   # Import file storage, because we need to customize things in order for it
   # to work with Django.
   from faker_file.storages.filesystem import FileSystemStorage

   from upload.models import Upload

   # Add all providers we want to use
   Faker.add_provider(BinFileProvider)
   Faker.add_provider(CsvFileProvider)
   Faker.add_provider(DocxFileProvider)
   Faker.add_provider(EmlFileProvider)
   Faker.add_provider(EpubFileProvider)
   Faker.add_provider(IcoFileProvider)
   Faker.add_provider(JpegFileProvider)
   Faker.add_provider(Mp3FileProvider)
   Faker.add_provider(OdsFileProvider)
   Faker.add_provider(OdtFileProvider)
   Faker.add_provider(PdfFileProvider)
   Faker.add_provider(PngFileProvider)
   Faker.add_provider(PptxFileProvider)
   Faker.add_provider(RtfFileProvider)
   Faker.add_provider(SvgFileProvider)
   Faker.add_provider(TxtFileProvider)
   Faker.add_provider(WebpFileProvider)
   Faker.add_provider(XlsxFileProvider)
   Faker.add_provider(ZipFileProvider)

   # Define a file storage. When working with Django and FileSystemStorage
   # you need to set the value of `root_path` argument to
   # `settings.MEDIA_ROOT`.
   STORAGE = FileSystemStorage(root_path=settings.MEDIA_ROOT, rel_path="tmp")


   class UploadFactory(DjangoModelFactory):
       """Upload factory."""

       name = Faker("text", max_nb_chars=100)
       description = Faker("text", max_nb_chars=1000)

       class Meta:
           model = Upload

       class Params:
           bin_file = Trait(file=Faker("bin_file", storage=STORAGE))
           csv_file = Trait(file=Faker("csv_file", storage=STORAGE))
           docx_file = Trait(file=Faker("docx_file", storage=STORAGE))
           eml_file = Trait(file=Faker("eml_file", storage=STORAGE))
           epub_file = Trait(file=Faker("epub_file", storage=STORAGE))
           ico_file = Trait(file=Faker("ico_file", storage=STORAGE))
           jpeg_file = Trait(file=Faker("jpeg_file", storage=STORAGE))
           mp3_file = Trait(file=Faker("mp3_file", storage=STORAGE))
           ods_file = Trait(file=Faker("ods_file", storage=STORAGE))
           odt_file = Trait(file=Faker("odt_file", storage=STORAGE))
           pdf_file = Trait(file=Faker("pdf_file", storage=STORAGE))
           png_file = Trait(file=Faker("png_file", storage=STORAGE))
           pptx_file = Trait(file=Faker("pptx_file", storage=STORAGE))
           rtf_file = Trait(file=Faker("rtf_file", storage=STORAGE))
           svg_file = Trait(file=Faker("svg_file", storage=STORAGE))
           txt_file = Trait(file=Faker("txt_file", storage=STORAGE))
           webp_file = Trait(file=Faker("webp_file", storage=STORAGE))
           xlsx_file = Trait(file=Faker("xlsx_file", storage=STORAGE))
           zip_file = Trait(file=Faker("zip_file", storage=STORAGE))

And then somewhere in your code:

   UploadFactory(bin_file=True)  # Upload with BIN file
   UploadFactory(docx_file=True)  # Upload with DOCX file
   UploadFactory(jpeg_file=True)  # Upload with JPEG file
   UploadFactory(zip_file=True)  # Upload with ZIP file

*See the full example* "here"

======================================================================


Randomize provider choice
~~~~~~~~~~~~~~~~~~~~~~~~~

   from random import choice
   from factory import Faker, LazyAttribute, Trait
   from faker import Faker as OriginalFaker

   FAKER = OriginalFaker()
   FAKER.add_provider(BinFileProvider)
   FAKER.add_provider(CsvFileProvider)
   FAKER.add_provider(DocxFileProvider)
   FAKER.add_provider(EmlFileProvider)
   FAKER.add_provider(EpubFileProvider)
   FAKER.add_provider(IcoFileProvider)
   FAKER.add_provider(JpegFileProvider)
   FAKER.add_provider(Mp3FileProvider)
   FAKER.add_provider(OdsFileProvider)
   FAKER.add_provider(OdtFileProvider)
   FAKER.add_provider(PdfFileProvider)
   FAKER.add_provider(PngFileProvider)
   FAKER.add_provider(PptxFileProvider)
   FAKER.add_provider(RtfFileProvider)
   FAKER.add_provider(SvgFileProvider)
   FAKER.add_provider(TxtFileProvider)
   FAKER.add_provider(WebpFileProvider)
   FAKER.add_provider(XlsxFileProvider)
   FAKER.add_provider(ZipFileProvider)


   def random_file_generator(*args, **kwargs):
       random_provider = choice(
           [
               "bin_file",
               "csv_file",
               "docx_file",
               "eml_file",
               "epub_file",
               "ico_file",
               "jpeg_file",
               "mp3_file",
               "ods_file",
               "odt_file",
               "pdf_file",
               "png_file",
               "pptx_file",
               "rtf_file",
               "svg_file",
               "txt_file",
               "webp_file",
               "xlsx_file",
               "zip_file",
           ]
       )
       func = getattr(FAKER, random_provider)
       return func(storage=STORAGE)


   class UploadFactory(DjangoModelFactory):
       """Upload factory."""

       name = Faker("text", max_nb_chars=100)
       description = Faker("text", max_nb_chars=1000)

       class Meta:
           model = Upload

       class Params:
           random_file = Trait(file=LazyAttribute(random_file_generator))

And then somewhere in your code:

   # Upload with randon file
   upload = UploadFactory(random_file=True)

*See the full example* "here"


Use a different locale
~~~~~~~~~~~~~~~~~~~~~~

       Faker.add_provider(OdtFileProvider)
       upload = UploadFactory()

*See the full example* "here"


Other Django usage examples
~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Faker example with AWS S3 storage**

   from faker import Faker
   from faker_file.storages.aws_s3 import AWSS3Storage

   STORAGE = AWSS3Storage(
       bucket_name=settings.AWS_STORAGE_BUCKET_NAME,
       root_path="",
       rel_path="",
   )

   FAKER = Faker()
   FAKER.add_provider(PdfFileProvider)

   pdf_file = FAKER.pdf_file(storage=STORAGE)

*See the full example* "here"

======================================================================

**factory-boy example with AWS S3 storage**

   from factory import Faker
   from faker_file.providers.pdf_file import PdfFileProvider
   from faker_file.storages.aws_s3 import AWSS3Storage

   STORAGE = AWSS3Storage(
       bucket_name=settings.AWS_STORAGE_BUCKET_NAME,
       root_path="",
       rel_path="",
   )

   Faker.add_provider(PdfFileProvider)


   class UploadFactory(DjangoModelFactory):
       name = Faker("word")
       description = Faker("text")
       file = Faker("pdf_file", storage=STORAGE)

       class Meta:
           model = Upload


   # Usage example
   upload = UploadFactory()

*See the full example* "here"

======================================================================

**Flexible storage selection**

   from django.core.files.storage import default_storage
   from faker_file.storages.aws_s3 import AWSS3Storage
   from faker_file.storages.filesystem import FileSystemStorage
   from storages.backends.s3boto3 import S3Boto3Storage

   # Faker doesn't know anything about Django. That's why, if we want to
   # support remote storages, we need to manually check which file storage
   # backend is used. If `Boto3` storage backend (of the `django-storages`
   # package) is used we use the correspondent `AWSS3Storage` class of the
   # `faker-file`.
   # Otherwise, fall back to native file system storage (`FileSystemStorage`)
   # of the `faker-file`.
   if isinstance(default_storage, S3Boto3Storage):
       STORAGE = AWSS3Storage(
           bucket_name=settings.AWS_STORAGE_BUCKET_NAME,
           credentials={
               "key_id": settings.AWS_ACCESS_KEY_ID,
               "key_secret": settings.AWS_SECRET_ACCESS_KEY,
           },
           root_path="",
           rel_path="tmp",
       )
   else:
       STORAGE = FileSystemStorage(
           root_path=settings.MEDIA_ROOT,
           rel_path="tmp",
       )

*See the full example* "here"

======================================================================

======================================================================

======================================================================


Creating images
===============

Creating images could be a challenging task. System dependencies on
one side, large variety of many image formats on another.

Underlying creation of image files has been delegated to an
abstraction layer of image generators. If you don't like how image
files are generated or format you need isn't supported, you can create
your own layer, using your favourite library.

Generally speaking, in >>`faker-file`_<< each file provider represents
a certain file type (with only a few exceptions). For generating a
file in PNG format you should use *PngFileProvider*. For JPEG you
would use *JpegFileProvider*.


Image providers
---------------

Currently, there are 3 types of image providers implemented:

* Graphic-only image providers.

* Mixed-content image providers.

* Image augmentation providers.

The graphic-only image providers are only capable of producing random
graphics.

The mixed-content image providers can produce an image consisting of
both text and graphics. Moreover, text comes in variety of different
headings (such as h1, h2, h3, etc), paragraphs and tables.

Image augmentation providers simply augment existing images in a
various, declaratively random, ways, such as: flip, resize, lighten,
darken, grayscale and others.


Image generators
----------------

The following image generators are available.

* "PilImageGenerator", built on top of the >>`Pillow`_<<. It's the
  generator that will likely won't ask for any system dependencies
  that you don't yet have installed.

* "ImgkitImageGenerator" (default), built on top of the imgkit and
  >>`wkhtmltopdf`_<<. Extremely easy to work with. Supports many
  formats.

* "WeasyPrintImageGenerator", built on top of the WeasyPrint. Easy to
  work with. Supports formats that imgkit does not.


Building mixed-content images using imgkit
------------------------------------------

While imgkit generator is heavier and has >>`wkhtmltopdf`_<< as a
system dependency, it produces better quality images and has no issues
with fonts or unicode characters.

See the following full functional snippet for generating images using
imgkit.

   from faker import Faker
   from faker_file.providers.image.imgkit_generator import ImgkitImageGenerator
   from faker_file.providers.png_file import PngFileProvider

   FAKER = Faker()  # Initialize Faker
   FAKER.add_provider(PngFileProvider)  # Register PngFileProvider

   # Generate PNG file using `imgkit`
   pdf_file = FAKER.png_file(image_generator_cls=ImgkitImageGenerator)

*See the full example* "here"

The generated PNG image will have 10,000 characters of text. The
generated image will be as wide as needed to fit those 10,000
characters, but newlines are respected.

======================================================================

If you want image to be less wide, set value of "wrap_chars_after" to
80 characters (or any other number that fits your needs). See the
example below:

   # Generate an image file, wrapping each line after 80 characters
   png_file = FAKER.png_file(
       image_generator_cls=ImgkitImageGenerator, wrap_chars_after=80
   )

*See the full example* "here"

======================================================================

To have a longer text, increase the value of "max_nb_chars"
accordingly. See the example below:

   # Generate an image file of 20,000 characters
   png_file = FAKER.png_file(
       image_generator_cls=ImgkitImageGenerator, max_nb_chars=20_000
   )

*See the full example* "here"

======================================================================

As mentioned above, it's possible to diversify the generated context
with images, paragraphs, tables and pretty much everything that you
could think of, although currently only images, paragraphs and tables
are supported out of the box. In order to customise the blocks image
file is built from, the "DynamicTemplate" class is used. See the
example below for usage examples:

   from faker_file.base import DynamicTemplate
   from faker_file.contrib.image.imgkit_snippets import (
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create an image file with a paragraph, a picture and a table.
   # The ``DynamicTemplate`` simply accepts a list of callables (such
   # as ``add_paragraph``, ``add_picture``) and dictionary to be later on
   # fed to the callables as keyword arguments for customising the default
   # values.
   png_file = FAKER.png_file(
       image_generator_cls=ImgkitImageGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_picture, {}),  # Add picture
               (add_table, {}),  # Add table
           ]
       ),
   )

   # You could make the list as long as you like or simply multiply for
   # easier repetition as follows:
   png_file = FAKER.png_file(
       image_generator_cls=ImgkitImageGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_picture, {}),  # Add picture
               (add_table, {}),  # Add table
           ]
           * 5  # Will repeat your config 5 times
       ),
   )

*See the full example* "here"


Building mixed-content images using WeasyPrint
----------------------------------------------

While WeasyPrint generator isn't better or faster than the imgkit, it
supports formats that imgkit doesn't (and vice-versa) and therefore is
a good alternative to.

See the following snippet for generating images using WeasyPrint.

   from faker_file.providers.image.weasyprint_generator import (
       WeasyPrintImageGenerator,
   )

   # Generate image file using `WeasyPrint`
   png_file = FAKER.png_file(image_generator_cls=WeasyPrintImageGenerator)

*See the full example* "here"

======================================================================

All examples shown for imgkit apply for WeasyPrint generator, however
when building images files from blocks (paragraphs, images and
tables), the imports shall be adjusted:

As mentioned above, it's possible to diversify the generated context
with images, paragraphs, tables and pretty much everything else that
you could think of, although currently only images, paragraphs and
tables are supported. In order to customise the blocks image file is
built from, the "DynamicTemplate" class is used. See the example below
for usage examples:

   from faker_file.contrib.image.weasyprint_snippets import (
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create an image file with paragraph, picture and table.
   # The ``DynamicTemplate`` simply accepts a list of callables (such
   # as ``add_paragraph``, ``add_picture``) and dictionary to be later on
   # fed to the callables as keyword arguments for customising the default
   # values.
   png_file = FAKER.png_file(
       image_generator_cls=WeasyPrintImageGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_picture, {}),  # Add picture
               (add_table, {}),  # Add table
           ]
       ),
   )

   # You could make the list as long as you like or simply multiply for
   # easier repetition as follows:
   png_file = FAKER.png_file(
       image_generator_cls=WeasyPrintImageGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_picture, {}),  # Add picture
               (add_table, {}),  # Add table
           ]
           * 5  # Will repeat your config 5 times
       ),
   )

*See the full example* "here"


Building mixed-content images using >>`Pillow`_<<
-------------------------------------------------

Usage example:

   from faker_file.providers.image.pil_generator import PilImageGenerator

   png_file = FAKER.png_file(image_generator_cls=PilImageGenerator)

*See the full example* "here"

======================================================================

With options:

   png_file = FAKER.png_file(
       image_generator_cls=PilImageGenerator,
       image_generator_kwargs={
           "encoding": "utf8",
           "font_size": 14,
           "page_width": 800,
           "page_height": 1200,
           "line_height": 16,
           "spacing": 5,
       },
       wrap_chars_after=100,
   )

*See the full example* "here"

======================================================================

All examples shown for imgkit and WeasyPrint apply to >>`Pillow`_<<
generator, however when building image files from blocks (paragraphs,
images and tables), the imports shall be adjusted. See the example
below:

   from faker_file.contrib.image.pil_snippets import (
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create an image file with paragraph, picture and table.
   # The ``DynamicTemplate`` simply accepts a list of callables (such as
   # ``add_paragraph``, ``add_picture``) and dictionary to be later on fed
   # to the callables as keyword arguments for customising the default
   # values.
   png_file = FAKER.png_file(
       image_generator_cls=PilImageGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_picture, {}),  # Add picture
               (add_table, {}),  # Add table
           ]
       ),
   )

   # You could make the list as long as you like or simply multiply for
   # easier repetition as follows:
   png_file = FAKER.png_file(
       image_generator_cls=PilImageGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_picture, {}),  # Add picture
               (add_table, {}),  # Add table
           ]
           * 5  # Will repeat your config 5 times
       ),
   )

*See the full example* "here"


Creating graphics-only images using >>`Pillow`_<<
-------------------------------------------------

There are so called "graphic" image file providers available. Produced
image files would not contain text, so don't use it when you need text
based content. However, sometimes you just need a valid image file,
without caring much about the content. That's where graphic image
providers comes to rescue:

   from faker_file.providers.png_file import GraphicPngFileProvider

   FAKER.add_provider(GraphicPngFileProvider)  # Register provider

   png_file = FAKER.graphic_png_file()

*See the full example* "here"

The generated file will contain a random graphic (consisting of lines
and shapes of different colours).

======================================================================

One of the most useful arguments supported is "size".

   png_file = FAKER.graphic_png_file(size=(800, 800))

*See the full example* "here"


Augment existing images
-----------------------

Augment the input image with a series of random augmentation methods.

   from faker_file.providers.augment_image_from_path import (
       AugmentImageFromPathProvider,
   )
   from faker_file.providers.augment_random_image_from_dir import (
       AugmentRandomImageFromDirProvider,
   )
   from faker_file.providers.image.augment import (
       add_brightness,
       decrease_contrast,
       flip_horizontal,
       flip_vertical,
       resize_height,
       resize_width,
   )

   FAKER.add_provider(AugmentImageFromPathProvider)
   FAKER.add_provider(AugmentRandomImageFromDirProvider)

   # We assumed that directory "/tmp/tmp/" exists and contains
   # image files, among which "01.png". Augmentations will be applied
   # sequentially, one by one until all fulfilled. If you wish to apply only
   # a random number of augmentations, but not all, pass the `num_steps`
   # argument, with value less than the number of `augmentations` provided.
   augmented_image_file = FAKER.augment_image_from_path(
       path="/tmp/tmp/01.png",
       augmentations=[
           (flip_horizontal, {}),
           (flip_vertical, {}),
           (decrease_contrast, {}),
           (add_brightness, {}),
           (resize_width, {"lower": 0.9, "upper": 1.1}),
           (resize_height, {"lower": 0.9, "upper": 1.1}),
       ],
       prefix="augmented_image_01_",
       # num_steps=3,
   )

   augmented_random_image_file = FAKER.augment_random_image_from_dir(
       source_dir_path="/tmp/tmp/",
       augmentations=[
           (flip_horizontal, {}),
           (flip_vertical, {}),
           (decrease_contrast, {}),
           (add_brightness, {}),
           (resize_width, {"lower": 0.9, "upper": 1.1}),
           (resize_height, {"lower": 0.9, "upper": 1.1}),
       ],
       prefix="augmented_random_image_",
       # num_steps=3,
   )

*See the full example* "here"

======================================================================


Creating PDF
============

PDF is certainly one of the most complicated formats out there. And
certainly one of the formats most of the developers will be having
trouble with, as there are many versions and dialects. That makes it
almost impossible and highly challenging to have **just one right
way** of creating PDF files. That's why, creation of PDF files has
been delegated to an abstraction layer of PDF generators. If you don't
like how PDF files are generated, you can create your own layer, using
your favourite library.

Currently, there are three PDF generators implemented:

* "PdfkitPdfGenerator" (default), built on top of the pdfkit and
  >>`wkhtmltopdf`_<<.

* "ReportlabPdfGenerator", build on top of the famous reportlab.

* "PilPdfGenerator", build on top of the >>`Pillow`_<<. Produced PDFs
  would contain images only (even texts are stored as images), unlike
  pdfkit or reportlab based solutions, where PDFs would simply contain
  selectable text. However, it's the generator that will likely won't
  ask for any system dependencies that you don't yet have installed.


Building PDF with text using pdfkit
-----------------------------------

While pdfkit generator is heavier and has >>`wkhtmltopdf`_<< as a
system dependency, it produces better quality PDFs and has no issues
with fonts or unicode characters.

See the following full functional snippet for generating PDF using
pdfkit.

   # Required imports
   from faker import Faker
   from faker_file.providers.pdf_file import PdfFileProvider
   from faker_file.providers.pdf_file.generators.pdfkit_generator import (
       PdfkitPdfGenerator,
   )

   FAKER = Faker()  # Initialize Faker
   FAKER.add_provider(PdfFileProvider)  # Register PdfFileProvider

   # Generate PDF file using `pdfkit`
   pdf_file = FAKER.pdf_file(pdf_generator_cls=PdfkitPdfGenerator)

*See the full example* "here"

The generated PDF will have 10,000 characters of text, which is about
2 pages.

If you want PDF with more pages, you could either:

* Increase the value of "max_nb_chars" accordingly.

* Set value of "wrap_chars_after" to 80 characters to force longer
  pages.

* Insert manual page breaks and other content.

======================================================================

See the example below for "max_nb_chars" tweak:

   # Generate PDF file of 20,000 characters, using `pdfkit`
   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=PdfkitPdfGenerator, max_nb_chars=20_000
   )

*See the full example* "here"

======================================================================

See the example below for "wrap_chars_after" tweak:

   # Generate PDF file, wrapping each line after 80 characters, using `pdfkit`
   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=PdfkitPdfGenerator, wrap_chars_after=80
   )

*See the full example* "here"

======================================================================

As mentioned above, it's possible to diversify the generated context
with images, paragraphs, tables, manual text break and pretty much
everything that is supported by PDF format specification, although
currently only images, paragraphs, tables and manual text breaks are
supported out of the box. In order to customise the blocks PDF file is
built from, the "DynamicTemplate" class is used. See the example below
for usage examples:

   from faker_file.base import DynamicTemplate
   from faker_file.contrib.pdf_file.pdfkit_snippets import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create a PDF file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=PdfkitPdfGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       ),
   )

   # You could make the list as long as you like or simply multiply for
   # easier repetition as follows:
   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=PdfkitPdfGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
           * 5  # Will repeat your config 5 times
       ),
   )

*See the full example* "here"


Building PDFs with text using reportlab
---------------------------------------

While reportlab generator is much lighter than the pdfkit and does not
have system dependencies, but might produce PDF files with
questionable encoding when generating unicode text.

See the following full functional snippet for generating PDF using
reportlab.

   from faker_file.providers.pdf_file.generators.reportlab_generator import (
       ReportlabPdfGenerator,
   )

   # Generate PDF file using `reportlab`
   pdf_file = FAKER.pdf_file(pdf_generator_cls=ReportlabPdfGenerator)

*See the full example* "here"

======================================================================

All examples shown for pdfkit apply for reportlab generator, however
when building PDF files from blocks (paragraphs, images, tables and
page breaks), the imports shall be adjusted.

As mentioned above, it's possible to diversify the generated context
with images, paragraphs, tables, manual text break and pretty much
everything that is supported by PDF format specification, although
currently only images, paragraphs, tables and manual text breaks are
supported. In order to customise the blocks PDF file is built from,
the "DynamicTemplate" class is used. See the example below for usage
examples:

   from faker_file.contrib.pdf_file.reportlab_snippets import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create a PDF file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=ReportlabPdfGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       ),
   )

   # You could make the list as long as you like or simply multiply for
   # easier repetition as follows:
   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=ReportlabPdfGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
           * 5  # Will repeat your config 5 times
       ),
   )

*See the full example* "here"


Building PDFs with text using >>`Pillow`_<<
-------------------------------------------

Usage example:

   from faker_file.providers.pdf_file.generators.pil_generator import (
       PilPdfGenerator,
   )

   pdf_file = FAKER.pdf_file(pdf_generator_cls=PilPdfGenerator)

*See the full example* "here"

======================================================================

With options:

   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=PilPdfGenerator,
       pdf_generator_kwargs={
           "encoding": "utf8",
           "font_size": 14,
           "page_width": 800,
           "page_height": 1200,
           "line_height": 16,
           "spacing": 5,
       },
       wrap_chars_after=100,
   )

*See the full example* "here"

======================================================================

All examples shown for pdfkit and reportlab apply to >>`Pillow`_<<
generator, however when building PDF files from blocks (paragraphs,
images, tables and page breaks), the imports shall be adjusted.

As mentioned above, it's possible to diversify the generated context
with images, paragraphs, tables, manual text break and pretty much
everything that is supported by PDF format specification, although
currently only images, paragraphs, tables and manual text breaks are
supported. In order to customise the blocks PDF file is built from,
the "DynamicTemplate" class is used. See the example below for usage
examples:

   from faker_file.contrib.pdf_file.pil_snippets import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create a PDF file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=PilPdfGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       ),
   )

   # You could make the list as long as you like or simply multiply for
   # easier repetition as follows:
   pdf_file = FAKER.pdf_file(
       pdf_generator_cls=PilPdfGenerator,
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
           * 5  # Will repeat your config 5 times
       ),
   )

*See the full example* "here"


Creating PDFs with graphics using >>`Pillow`_<<
-----------------------------------------------

There's a so called *graphic* PDF file provider available. Produced
PDF files would not contain text, so don't use it when you need text
based content. However, sometimes you just need a valid file in PDF
format, without caring much about the content. That's where a
GraphicPdfFileProvider comes to rescue:

   from faker_file.providers.pdf_file import GraphicPdfFileProvider

   pdf_file = FAKER.graphic_pdf_file()

*See the full example* "here"

The generated file will contain a random graphic (consisting of lines
and shapes of different colours).

======================================================================

One of the most useful arguments supported is "size".

   pdf_file = FAKER.graphic_pdf_file(size=(800, 800))

*See the full example* "here"

======================================================================


Creating DOCX
=============

See the following full functional snippet for generating DOCX.

   # Required imports
   from faker import Faker
   from faker_file.providers.docx_file import DocxFileProvider

   FAKER = Faker()  # Initialize Faker
   FAKER.add_provider(DocxFileProvider)  # Register DocxFileProvider

   # Generate DOCX file
   docx_file = FAKER.docx_file()

*See the full example* "here"

The generated DOCX will have 10,000 characters of text, which is about
5 pages.

If you want DOCX with more pages, you could either:

* Increase the value of "max_nb_chars" accordingly.

* Set value of "wrap_chars_after" to 80 characters to force longer
  pages.

* Insert manual page breaks and other content.

======================================================================

See the example below for "max_nb_chars" tweak:

   # Generate DOCX file of 20,000 characters
   docx_file = FAKER.docx_file(max_nb_chars=20_000)

*See the full example* "here"

======================================================================

See the example below for "wrap_chars_after" tweak:

   # Generate DOCX file, wrapping each line after 80 characters
   docx_file = FAKER.docx_file(wrap_chars_after=80)

*See the full example* "here"

======================================================================

As mentioned above, it's possible to diversify the generated context
with images, paragraphs, tables, manual text break and pretty much
everything that is supported by DOCX format specification, although
currently only images, paragraphs, tables and manual text breaks are
supported out of the box. In order to customise the blocks DOCX file
is built from, the "DynamicTemplate" class is used. See the example
below for usage examples:

   from faker_file.base import DynamicTemplate
   from faker_file.contrib.docx_file import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create a DOCX file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   docx_file = FAKER.docx_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       )
   )

   # You could make the list as long as you like or simply multiply for
   # easier repetition as follows:
   docx_file = FAKER.docx_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
           * 5  # Will repeat your config 5 times
       )
   )

*See the full example* "here"

======================================================================


Creating ODT
============

See the following full functional snippet for generating ODT.

   # Required imports
   from faker import Faker
   from faker_file.providers.odt_file import OdtFileProvider

   FAKER = Faker()  # Initialize Faker
   FAKER.add_provider(OdtFileProvider)  # Register OdtFileProvider

   # Generate ODT file
   odt_file = FAKER.odt_file()

*See the full example* "here"

The generated ODT will have 10,000 characters of text, which is about
5 pages.

If you want ODT with more pages, you could either:

* Increase the value of "max_nb_chars" accordingly.

* Set value of "wrap_chars_after" to 80 characters to force longer
  pages.

* Insert manual page breaks and other content.

======================================================================

See the example below for "max_nb_chars" tweak:

   # Generate ODT file of 20,000 characters
   odt_file = FAKER.odt_file(max_nb_chars=20_000)

*See the full example* "here"

======================================================================

See the example below for "wrap_chars_after" tweak:

   # Generate ODT file, wrapping each line after 80 characters
   odt_file = FAKER.odt_file(wrap_chars_after=80)

*See the full example* "here"

======================================================================

As mentioned above, it's possible to diversify the generated context
with images, paragraphs, tables, manual text break and pretty much
everything that is supported by ODT format specification, although
currently only images, paragraphs, tables and manual text breaks are
supported out of the box. In order to customise the blocks ODT file is
built from, the "DynamicTemplate" class is used. See the example below
for usage examples:

   from faker_file.base import DynamicTemplate
   from faker_file.contrib.odt_file import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create a ODT file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   odt_file = FAKER.odt_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       )
   )

   # You could make the list as long as you like or simply multiply for
   # easier repetition as follows:
   odt_file = FAKER.odt_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
           * 5  # Will repeat your config 5 times
       )
   )

*See the full example* "here"

======================================================================


Concepts
========

*faker-file* is designed to generate files with synthetic data. It can
work with a variety of file types, such as TXT, DOCX, PDF, PPTX, EML,
and ZIP files.

It uses the *Faker* library to generate synthetic (fake) data. This
data can be used as the content of the generated files, allowing for
files with realistic, but synthetic, content.


Providers
---------

*faker-file* includes different file providers for each file type.
They are responsible for the creation of the files, each having a
method to create a specific file type:

* "DocxFileProvider"

* "PdfFileProvider"

* "PptxFileProvider"

* "TxtFileProvider"

* "ZipFileProvider"

* "EmlFileProvider"


Inner functions
---------------

*faker-file* includes a module named
"faker_file.providers.helpers.inner" that contains helper functions,
referred to as "inner functions". These functions are used to create
files that are nested within other files (e.g., creating DOCX files
within a ZIP file).

List of inner functions:

* "create_inner_docx_file"

* "create_inner_zip_file"

* "create_inner_eml_file"

* "create_inner_epub_file"

* "create_inner_txt_file"

* "fuzzy_choice_create_inner_file"

* "list_create_inner_file"

These inner functions are used to create a variety of files and
structure them in various ways, such as creating DOCX files in ZIP
files, or creating nested ZIP files. They also allow for the creation
of files with dynamic content or content based on templates, as well
as control over the naming and directory structure of the files.


File customization
------------------

"faker-file" allows for various customization options for file
generation. Examples include static or dynamic content generation,
character limits, line wrapping, filename prefixing, and more.


Storage
-------

*faker-file* uses pluggable storages, which are responsible for
managing how and where files are stored in the (remote) file system.


DynamicTemplate
---------------

"DynamicTemplate" is a wrapper used for creating DOCX and ODT files
with tables and images. This feature allows for full control over the
content creation process. It requires a list of tuples as input, where
each tuple contains a callable function and a dictionary of keyword
arguments. The callable function should accept arguments including a
Faker generator or instance, a document instance, a dictionary for
data, a counter, and an optional dictionary for additional arguments.
This feature demonstrates how to create a DOCX or ODT file with a
table and an image.


GenericFileProvider
-------------------

"GenericFileProvider" allows you to create files in any format from a
predefined template. This is particularly useful when you want to
generate a file in a format that is not directly supported by the
library.

======================================================================


Methodology
===========


But why
-------

Let's start with some hypothetical questions.

"But why generate testing files dynamically", - you may ask?

And the answer would be, - "for a number of reasons":

Because you do need files and managing test files is a pain nobody
wants to have. You create testing files for one use case, then you
need to support another, but you need to modify the original files or
make modifications there. You either duplicate or make changes, then
at some point, after a number of iterations, your test files
collection grows so big, you can't easily find out how some of the
test files different one from another or your test fail, you spend
some time to investigate and find out that there has been a slight
modification of one of the files, which made your pipeline to fail.
You fix the error and decide to document your collection (a good thing
anyway). But then your collection grows even more. The burden of
managing both test files, the documentation of the test files and the
test code becomes unbearable.

Now imagine doing it not for one, but for a number of projects. You
want to be smart and make a collection of files, document it properly
and think you've done a good job, but then you start to realise that
you do need to deviate or add new files to the collection to support
new use cases. You want to be safe and decide to version control it.
Your collection grows, you start ot accept PRs from other devs and go
down the rabbit whole of owning another critical repository. Your
documentation grows and so does the repository size (mostly binary
content). Storing such a huge amount of files becomes a burden. It
slows down everyone.

Not even talking about, that you might not be allowed to store some of
the you're using for testing centrally, because you would then need to
run obfuscation, anonymization to legally address concerns of privacy
regulations.


When test files are generated dynamically
-----------------------------------------

When test files are generated dynamically, you are relieved from most
of the concerns mentioned above. There are a couple of drawbacks here
too, such as tests execution time (because generating of the test
files on the fly does require some computation resources and therefore
- your CI execution time will grow).


Best practices
--------------

In some very specific use-cases, mimicking original files might be too
difficult and you might want to still consider including some of the
very specific and hard-to-recreate files in the project repository,
but on much lower scale. Use >>`faker-file`_<< for simple use cases
and only use custom files when things get too complicated otherwise.
The so-called hybrid approach.


Identify what kind of files do you need
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

>>`faker-file`_<< supports a large variety of file types, but content
of files can be generally broken down by 2 categories:

* Text based: Useful when testing OCR or text processing pipelines.
  ATM, most of the >>`faker-file`_<< providers generate text-based
  content.

* Non-text based: Typically images and non-human readable formats such
  as BIN. Useful when you need to test validity of the uploaded file,
  but don't care much about what's inside.

Image providers:

+--------+---------------------------+--------------------+---------------------------+
| File   | Graphic                   | Text               | Generator                 |
| type   |                           |                    |                           |
|========|===========================|====================|===========================|
| BMP    | GraphicBmpFileProvider    | BmpFileProvider    | Pillow, WeasyPrint        |
+--------+---------------------------+--------------------+---------------------------+
| GIF    | GraphicGifFileProvider    | GifFileProvider    | Pillow, WeasyPrint        |
+--------+---------------------------+--------------------+---------------------------+
| ICO    | GraphicIcoFileProvider    | IcoFileProvider    | Pillow, Imagekit,         |
|        |                           |                    | WeasyPrint                |
+--------+---------------------------+--------------------+---------------------------+
| JPEG   | GraphicJpegFileProvider   | JpegFileProvider   | Pillow, Imagekit,         |
|        |                           |                    | WeasyPrint                |
+--------+---------------------------+--------------------+---------------------------+
| PDF    | GraphicPdfFileProvider    | PdfFileProvider    | Pillow, Imagekit,         |
|        |                           |                    | WeasyPrint                |
+--------+---------------------------+--------------------+---------------------------+
| PNG    | GraphicPngFileProvider    | PngFileProvider    | Pillow, Imagekit,         |
|        |                           |                    | WeasyPrint                |
+--------+---------------------------+--------------------+---------------------------+
| SVG    | (not supported)           | SvgFileProvider    | Imagekit                  |
+--------+---------------------------+--------------------+---------------------------+
| TIFF   | GraphicTiffFileProvider   | TiffFileProvider   | Pillow, Imagekit*,        |
|        |                           |                    | WeasyPrint                |
+--------+---------------------------+--------------------+---------------------------+
| WEBP   | GraphicWebpFileProvider   | WebpFileProvider   | Pillow, Imagekit*,        |
|        |                           |                    | WeasyPrint                |
+--------+---------------------------+--------------------+---------------------------+

Note:

  Items marked with *** may require xvfb to function properly.

At the moment, 2 of the 3 text-to-image providers require additional
system dependencies (such as >>`wkhtmltopdf`_<< for imgkit and poppler
for WeasyPrint, both of which are available for most popular operating
systems, including Windows, macOS and Linux).

A few formats, such as BMP, GIF and TIFF, which are not supported by
imgkit and underlying >>`wkhtmltopdf`_<<, rely on WeasyPrint,
pdf2image and poppler through the "WeasyPrintImageGenerator".

The lightest alternative to imgkit and WeasyPrint generators is the
>>`Pillow`_<< generator ("PilImageGenerator"), which is basic, but
does not require additional system dependencies to be installed (most
of the system dependencies for >>`Pillow`_<< are likely already
installed on your system: "libjpeg", "zlib", "libtiff", "libfreetype6"
and "libwebp").

Graphic image providers on the other hand rely on >>`Pillow`_<< and
underlying system dependencies mentioned above.

Take a good look at the >>`prerequisites`_<< to identify required
dependencies.

TL;DR

For text-to-image file generation you could use >>`Pillow`_<< based
generators, which are basic, but do not require additional system
dependencies. For advanced text-to-image file generation you could use
either imgkit or WeasyPrint based generators, which require
>>`wkhtmltopdf`_<< and poppler respectively.

For graphic file generation, the only option is to use graphic file
providers, which depend on *Pillow* (and underlying system
dependencies) only.


Installation
~~~~~~~~~~~~

When using >>`faker-file`_<< for automated tests in a large project
with a lot of dependencies, the recommended way to install it is to
carefully pick the dependencies required and further use requirements
management package, like >>`pip-tools`_<<, to compile them into hashed
set of packages working well together.

For instance, if we only need DOCX and PDF support, your
"requirements.in" file could look as follows:

   faker
   faker-file
   python-docx
   reportlab

If you only plan to use >>`faker-file`_<< as a CLI application, just
install all common dependencies as follows:

   pipx install "faker-file[common]"


Creating files
~~~~~~~~~~~~~~

A couple of use-cases when >>`faker-file`_<< can help you out:


Create a simple DOCX file
"""""""""""""""""""""""""

Let's imagine we need to generate a DOCX file with text 50 chars long
(just for observability).

   from faker import Faker
   from faker_file.providers.docx_file import DocxFileProvider

   FAKER = Faker()
   FAKER.add_provider(DocxFileProvider)

   docx_file = FAKER.docx_file(max_nb_chars=50)
   print(docx_file)  # Sample value: 'tmp/tmpgdctmfbp.docx'
   print(docx_file.data["content"])  # Sample value: 'Learn where receive social.'
   print(docx_file.data["filename"])  # Sample value: '/tmp/tmp/tmpgdctmfbp.docx'

*See the full example* "here"


Create a more structured DOCX file
""""""""""""""""""""""""""""""""""

Imagine, you need a letter sample. It contains

   TEMPLATE = """
   {{date}} {{city}}, {{country}}

   Hello {{name}},

   {{text}}

   Address: {{address}}

   Best regards,

   {{name}}
   {{address}}
   {{phone_number}}
   """

   docx_file = FAKER.docx_file(content=TEMPLATE)

   print(docx_file)  # Sample value: 'tmp/tmpgdctmfbp.docx'
   print(docx_file.data["content"])
   # Sample value below:
   #  2009-05-14 Pettyberg, Puerto Rico
   #  Hello Lauren Williams,
   #
   #  Everyone bill I information. Put particularly note language support
   #  green. Game free family probably case day vote.
   #  Commercial especially game heart.
   #
   #  Address: 19017 Jennifer Drives
   #  Jamesbury, MI 39121
   #
   #  Best regards,
   #
   #  Robin Jones
   #  4650 Paul Extensions
   #  Port Johnside, VI 78151
   #  001-704-255-3093

*See the full example* "here"


Create even more structured DOCX file
"""""""""""""""""""""""""""""""""""""

Imagine, you need to generate a highly custom document with types of
data, such as images, tables, manual page breaks, paragraphs, etc.

   from faker_file.base import DynamicTemplate
   from faker_file.contrib.docx_file import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create a DOCX file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   docx_file = FAKER.docx_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       )
   )

*See the full example* "here"

Note:

  All callables do accept arguments. You could provide
  "content=TEMPLATE" argument to the "add_paragraph" function and
  instead of just random text, you would get a more structured
  paragraph (from one of previous examples).


For when you think >>`faker-file`_<< isn't enough
"""""""""""""""""""""""""""""""""""""""""""""""""

As previously mentioned, sometimes when test documents are too complex
it might be hard to replicate them and you want to store just a few
very specific documents in the project repository.

>>`faker-file`_<< comes up with a couple of providers that might still
help you in that case.

Both FileFromPathProvider and RandomFileFromDirProvider are created to
support the hybrid approach.


FileFromPathProvider
++++++++++++++++++++

Create a file by copying it from the given path.

* Create an exact copy of a file under a different name.

* Prefix of the destination file would be "zzz".

* "path" is the absolute path to the file to copy.

   from faker_file.providers.file_from_path import FileFromPathProvider

   FAKER.add_provider(FileFromPathProvider)

   # We assume that directory "/tmp/tmp/" exists and contains a file named
   # "file.docx".
   docx_file_copy = FAKER.file_from_path(
       path="/tmp/tmp/file.docx",
       prefix="zzz",
   )

*See the full example* "here"

Now you don't have to copy-paste your file from one place to another.
It will be done for you in a convenient way.


RandomFileFromDirProvider
+++++++++++++++++++++++++

Create a file by copying it randomly from the given directory.

* Create an exact copy of the randomly picked file under a different
  name.

* Prefix of the destination file would be "zzz".

* "source_dir_path" is the absolute path to the directory to pick
  files from.

   from faker_file.providers.random_file_from_dir import RandomFileFromDirProvider

   FAKER.add_provider(RandomFileFromDirProvider)

   # We assume that directory "/tmp/tmp/" exists and contains files with".docx"
   # extension.
   docx_file_copy = FAKER.random_file_from_dir(
       source_dir_path="/tmp/tmp/",
       prefix="zzz",
   )

*See the full example* "here"

Now you don't have to copy-paste your file from one place to another.
It will be done for you in a convenient way.


Clean up files
~~~~~~~~~~~~~~

"FileSystemStorage" is the default storage and by default files are
stored inside a "tmp" directory within the system's temporary
directory, which is commonly cleaned up after system restart. However,
there's a mechanism of cleaning up files after the tests run. At any
time, to clean up all files created by that moment, call "clean_up"
method of the "FileRegistry" class instance, as shown below:

   # Import instance at once
   from faker_file.registry import FILE_REGISTRY

   # Trigger the clean-up
   FILE_REGISTRY.clean_up()

*See the full example* "here"

Typically you would call the "clean_up" method in the "tearDown".

======================================================================

To remove a single file, use "remove" method of "FileRegistry"
instance.

   # We assume that there's an initialized `txt_file` instance to remove.
   FILE_REGISTRY.remove(txt_file)  # Where file is an instance of ``StringValue``

*See the full example* "here"

======================================================================

If you only have a string representation of the "StringValue", try to
search for its' correspondent "StringValue" instance first using
"search" method.

   # We assume that there's an initialized `filename` (str) to remove.
   txt_file = FILE_REGISTRY.search(filename)
   if txt_file:
       FILE_REGISTRY.remove(txt_file)

*See the full example* "here"

======================================================================


Quick start
===========


Installation
------------

   pip install faker-file[all]


Usage
-----


With "Faker"
~~~~~~~~~~~~

**Imports and initialization**

   from faker import Faker
   from faker_file.providers.augment_file_from_dir import (
       AugmentFileFromDirProvider,
   )
   from faker_file.providers.bin_file import BinFileProvider
   from faker_file.providers.bmp_file import BmpFileProvider
   from faker_file.providers.csv_file import CsvFileProvider
   from faker_file.providers.docx_file import DocxFileProvider
   from faker_file.providers.eml_file import EmlFileProvider
   from faker_file.providers.epub_file import EpubFileProvider
   from faker_file.providers.gif_file import GifFileProvider
   from faker_file.providers.ico_file import (
       GraphicIcoFileProvider,
       IcoFileProvider,
   )
   from faker_file.providers.jpeg_file import (
       GraphicJpegFileProvider,
       JpegFileProvider,
   )
   from faker_file.providers.mp3_file import Mp3FileProvider
   from faker_file.providers.odp_file import OdpFileProvider
   from faker_file.providers.ods_file import OdsFileProvider
   from faker_file.providers.odt_file import OdtFileProvider
   from faker_file.providers.pdf_file import (
       GraphicPdfFileProvider,
       PdfFileProvider,
   )
   from faker_file.providers.png_file import (
       GraphicPngFileProvider,
       PngFileProvider,
   )
   from faker_file.providers.pptx_file import PptxFileProvider
   from faker_file.providers.random_file_from_dir import RandomFileFromDirProvider
   from faker_file.providers.rtf_file import RtfFileProvider
   from faker_file.providers.svg_file import SvgFileProvider
   from faker_file.providers.tar_file import TarFileProvider
   from faker_file.providers.tiff_file import TiffFileProvider
   from faker_file.providers.txt_file import TxtFileProvider
   from faker_file.providers.webp_file import (
       GraphicWebpFileProvider,
       WebpFileProvider,
   )
   from faker_file.providers.xlsx_file import XlsxFileProvider
   from faker_file.providers.zip_file import ZipFileProvider

   FAKER = Faker()
   FAKER.add_provider(AugmentFileFromDirProvider)
   FAKER.add_provider(BinFileProvider)
   FAKER.add_provider(BmpFileProvider)
   FAKER.add_provider(CsvFileProvider)
   FAKER.add_provider(DocxFileProvider)
   FAKER.add_provider(EmlFileProvider)
   FAKER.add_provider(EpubFileProvider)
   FAKER.add_provider(GifFileProvider)
   FAKER.add_provider(GraphicIcoFileProvider)
   FAKER.add_provider(GraphicJpegFileProvider)
   FAKER.add_provider(GraphicPdfFileProvider)
   FAKER.add_provider(GraphicPngFileProvider)
   FAKER.add_provider(GraphicWebpFileProvider)
   FAKER.add_provider(IcoFileProvider)
   FAKER.add_provider(JpegFileProvider)
   FAKER.add_provider(Mp3FileProvider)
   FAKER.add_provider(OdpFileProvider)
   FAKER.add_provider(OdsFileProvider)
   FAKER.add_provider(OdtFileProvider)
   FAKER.add_provider(PdfFileProvider)
   FAKER.add_provider(PngFileProvider)
   FAKER.add_provider(PptxFileProvider)
   FAKER.add_provider(RandomFileFromDirProvider)
   FAKER.add_provider(RtfFileProvider)
   FAKER.add_provider(SvgFileProvider)
   FAKER.add_provider(TarFileProvider)
   FAKER.add_provider(TiffFileProvider)
   FAKER.add_provider(TxtFileProvider)
   FAKER.add_provider(WebpFileProvider)
   FAKER.add_provider(XlsxFileProvider)
   FAKER.add_provider(ZipFileProvider)

**Usage examples**

   # augmented_file = FAKER.augment_file_from_dir(
   #     source_dir_path="/tmp/tmp/",
   # )
   bin_file = FAKER.bin_file()
   bmp_file = FAKER.bmp_file()
   csv_file = FAKER.csv_file()
   docx_file = FAKER.docx_file()
   eml_file = FAKER.eml_file()
   epub_file = FAKER.epub_file()
   gif_file = FAKER.gif_file()
   graphic_ico_file = FAKER.graphic_ico_file()
   graphic_jpeg_file = FAKER.graphic_jpeg_file()
   graphic_pdf_file = FAKER.graphic_pdf_file()
   graphic_png_file = FAKER.graphic_png_file()
   graphic_webp_file = FAKER.graphic_webp_file()
   ico_file = FAKER.ico_file()
   jpeg_file = FAKER.jpeg_file()
   mp3_file = FAKER.mp3_file()
   odp_file = FAKER.odp_file()
   ods_file = FAKER.ods_file()
   odt_file = FAKER.odt_file()
   pdf_file = FAKER.pdf_file()
   png_file = FAKER.png_file()
   pptx_file = FAKER.pptx_file()
   random_file = FAKER.random_file_from_dir(
       source_dir_path="/tmp/tmp/",
   )
   rtf_file = FAKER.rtf_file()
   svg_file = FAKER.svg_file()
   tar_file = FAKER.tar_file()
   tiff_file = FAKER.tiff_file()
   txt_file = FAKER.txt_file()
   # webp_file = FAKER.webp_file()
   xlsx_file = FAKER.xlsx_file()
   zip_file = FAKER.zip_file()

If you just need bytes back (instead of creating the file), provide
the "raw=True" argument (works with all provider classes and inner
functions):

   # augmented_raw = FAKER.augment_file_from_dir(
   #     source_dir_path="/tmp/tmp/",
   #     raw=True,
   # )
   bin_raw = FAKER.bin_file(raw=True)
   bmp_raw = FAKER.bmp_file(raw=True)
   csv_raw = FAKER.csv_file(raw=True)
   docx_raw = FAKER.docx_file(raw=True)
   eml_raw = FAKER.eml_file(raw=True)
   epub_raw = FAKER.epub_file(raw=True)
   gif_raw = FAKER.gif_file(raw=True)
   ico_raw = FAKER.ico_file(raw=True)
   jpeg_raw = FAKER.jpeg_file(raw=True)
   mp3_raw = FAKER.mp3_file(raw=True)
   odp_raw = FAKER.odp_file(raw=True)
   ods_raw = FAKER.ods_file(raw=True)
   odt_raw = FAKER.odt_file(raw=True)
   pdf_raw = FAKER.pdf_file(raw=True)
   png_raw = FAKER.png_file(raw=True)
   pptx_raw = FAKER.pptx_file(raw=True)
   random_raw = FAKER.random_file_from_dir(
       source_dir_path="/tmp/tmp/",
       raw=True,
   )
   rtf_raw = FAKER.rtf_file(raw=True)
   svg_raw = FAKER.svg_file(raw=True)
   tar_raw = FAKER.tar_file(raw=True)
   tiff_raw = FAKER.tiff_file(raw=True)
   txt_raw = FAKER.txt_file(raw=True)
   # webp_raw = FAKER.webp_file(raw=True)
   xlsx_raw = FAKER.xlsx_file(raw=True)
   zip_raw = FAKER.zip_file(raw=True)

*See the full example* "here"

======================================================================


With "factory_boy"
~~~~~~~~~~~~~~~~~~

**Imports and initialization**

   from factory import Faker, Trait
   from faker_file.providers.augment_file_from_dir import (
       AugmentFileFromDirProvider,
   )
   from faker_file.providers.bin_file import BinFileProvider
   from faker_file.providers.bmp_file import BmpFileProvider
   from faker_file.providers.csv_file import CsvFileProvider
   from faker_file.providers.docx_file import DocxFileProvider
   from faker_file.providers.eml_file import EmlFileProvider
   from faker_file.providers.epub_file import EpubFileProvider
   from faker_file.providers.ico_file import (
       GraphicIcoFileProvider,
       IcoFileProvider,
   )
   from faker_file.providers.jpeg_file import (
       GraphicJpegFileProvider,
       JpegFileProvider,
   )
   from faker_file.providers.mp3_file import Mp3FileProvider
   from faker_file.providers.odp_file import OdpFileProvider
   from faker_file.providers.ods_file import OdsFileProvider
   from faker_file.providers.odt_file import OdtFileProvider
   from faker_file.providers.pdf_file import (
       GraphicPdfFileProvider,
       PdfFileProvider,
   )
   from faker_file.providers.png_file import (
       GraphicPngFileProvider,
       PngFileProvider,
   )
   from faker_file.providers.pptx_file import PptxFileProvider
   from faker_file.providers.random_file_from_dir import RandomFileFromDirProvider
   from faker_file.providers.rtf_file import RtfFileProvider
   from faker_file.providers.svg_file import SvgFileProvider
   from faker_file.providers.tar_file import TarFileProvider
   from faker_file.providers.txt_file import TxtFileProvider
   from faker_file.providers.webp_file import (
       GraphicWebpFileProvider,
       WebpFileProvider,
   )
   from faker_file.providers.xlsx_file import XlsxFileProvider
   from faker_file.providers.zip_file import ZipFileProvider

   Faker.add_provider(AugmentFileFromDirProvider)
   Faker.add_provider(BinFileProvider)
   Faker.add_provider(BmpFileProvider)
   Faker.add_provider(CsvFileProvider)
   Faker.add_provider(DocxFileProvider)
   Faker.add_provider(EmlFileProvider)
   Faker.add_provider(EpubFileProvider)
   Faker.add_provider(GraphicIcoFileProvider)
   Faker.add_provider(GraphicJpegFileProvider)
   Faker.add_provider(GraphicPdfFileProvider)
   Faker.add_provider(GraphicPngFileProvider)
   Faker.add_provider(GraphicWebpFileProvider)
   Faker.add_provider(IcoFileProvider)
   Faker.add_provider(JpegFileProvider)
   Faker.add_provider(Mp3FileProvider)
   Faker.add_provider(OdpFileProvider)
   Faker.add_provider(OdsFileProvider)
   Faker.add_provider(OdtFileProvider)
   Faker.add_provider(PdfFileProvider)
   Faker.add_provider(PngFileProvider)
   Faker.add_provider(PptxFileProvider)
   Faker.add_provider(RandomFileFromDirProvider)
   Faker.add_provider(RtfFileProvider)
   Faker.add_provider(SvgFileProvider)
   Faker.add_provider(TarFileProvider)
   Faker.add_provider(TxtFileProvider)
   Faker.add_provider(WebpFileProvider)
   Faker.add_provider(XlsxFileProvider)
   Faker.add_provider(ZipFileProvider)

**upload/models.py**

   from django.db import models

   class Upload(models.Model):
       """Upload model."""

       name = models.CharField(max_length=255, unique=True)
       description = models.TextField(null=True, blank=True)

       # File
       file = models.FileField(null=True)

*See the full example* "here"

**upload/factories.py**

   from django.conf import settings
   from factory import Faker, Trait
   from factory.django import DjangoModelFactory
   from faker_file.storages.filesystem import FileSystemStorage

   from upload.models import Upload

   # Define a file storage, because we need to customize things in
   # order for it to work with Django.
   STORAGE = FileSystemStorage(root_path=settings.MEDIA_ROOT, rel_path="tmp")

   # Factories


   class UploadFactory(DjangoModelFactory):
       """Upload factory."""

       name = Faker("text", max_nb_chars=100)
       description = Faker("text", max_nb_chars=1000)

       class Meta:
           model = Upload

       class Params:
           bin_file = Trait(file=Faker("bin_file", storage=STORAGE))
           bmp_file = Trait(file=Faker("bmp_file", storage=STORAGE))
           csv_file = Trait(file=Faker("csv_file", storage=STORAGE))
           docx_file = Trait(file=Faker("docx_file", storage=STORAGE))
           eml_file = Trait(file=Faker("eml_file", storage=STORAGE))
           epub_file = Trait(file=Faker("epub_file", storage=STORAGE))
           ico_file = Trait(file=Faker("ico_file", storage=STORAGE))
           jpeg_file = Trait(file=Faker("jpeg_file", storage=STORAGE))
           mp3_file = Trait(file=Faker("mp3_file", storage=STORAGE))
           odp_file = Trait(file=Faker("odp_file", storage=STORAGE))
           ods_file = Trait(file=Faker("ods_file", storage=STORAGE))
           odt_file = Trait(file=Faker("odt_file", storage=STORAGE))
           pdf_file = Trait(file=Faker("pdf_file", storage=STORAGE))
           png_file = Trait(file=Faker("png_file", storage=STORAGE))
           pptx_file = Trait(file=Faker("pptx_file", storage=STORAGE))
           rtf_file = Trait(file=Faker("rtf_file", storage=STORAGE))
           svg_file = Trait(file=Faker("svg_file", storage=STORAGE))
           tar_file = Trait(file=Faker("tar_file", storage=STORAGE))
           txt_file = Trait(file=Faker("txt_file", storage=STORAGE))
           webp_file = Trait(file=Faker("webp_file", storage=STORAGE))
           xlsx_file = Trait(file=Faker("xlsx_file", storage=STORAGE))
           zip_file = Trait(file=Faker("zip_file", storage=STORAGE))

**Usage example**

   UploadFactory(bin_file=True)  # Upload with BIN file
   UploadFactory(docx_file=True)  # Upload with DOCX file
   UploadFactory(jpeg_file=True)  # Upload with JPEG file
   UploadFactory(zip_file=True)  # Upload with ZIP file

*See the full example* "here"

======================================================================


Recipes
=======


When using with "Faker"
-----------------------

When using with "Faker", there are two ways of using the providers.


Imports and initializations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Recommended way**

   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider

   FAKER = Faker()
   FAKER.add_provider(TxtFileProvider)

   # Usage example
   txt_file = FAKER.txt_file(content="Lorem ipsum")

*See the full example* "here"

**But this works too**

   from faker import Faker
   from faker_file.providers.txt_file import TxtFileProvider

   FAKER = Faker()

   # Usage example
   txt_file = TxtFileProvider(FAKER).txt_file(content="Lorem ipsum")

*See the full example* "here"

Throughout documentation we will be mixing these approaches.


Create a TXT file with static content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Content of the file is "Lorem ipsum".

   txt_file = FAKER.txt_file(content="Lorem ipsum")

*See the full example* "here"


Create a DOCX file with dynamically generated content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Content is generated dynamically.

* Content is limited to 1024 chars.

* Wrap lines after 80 chars.

* Prefix the filename with "zzz".

   docx_file = FAKER.docx_file(
       prefix="zzz",
       max_nb_chars=1_024,
       wrap_chars_after=80,
   )

*See the full example* "here"


Create a ZIP file consisting of TXT files with static content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 5 TXT files in the ZIP archive (default value is 5).

* Content of all files is "Lorem ipsum".

   zip_file = FAKER.zip_file(
       options={"create_inner_file_args": {"content": "Lorem ipsum"}}
   )

*See the full example* "here"


Create a ZIP file consisting of 3 DOCX files with dynamically generated content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 3 DOCX files in the ZIP archive.

* Content is generated dynamically.

* Content is limited to 1024 chars.

* Prefix the filenames in archive with "xxx_".

* Prefix the filename of the archive itself with "zzz".

* Inside the ZIP, put all files in directory "yyy".

   from faker_file.providers.helpers.inner import create_inner_docx_file

   zip_file = FAKER.zip_file(
       prefix="zzz",
       options={
           "count": 3,
           "create_inner_file_func": create_inner_docx_file,
           "create_inner_file_args": {
               "prefix": "xxx_",
               "max_nb_chars": 1_024,
           },
           "directory": "yyy",
       },
   )

*See the full example* "here"


Create a ZIP file of 9 DOCX files with content generated from template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 9 DOCX files in the ZIP archive.

* Content is generated dynamically from given template.

   from faker_file.providers.helpers.inner import create_inner_docx_file

   TEMPLATE = "Hey {{name}},\n{{text}},\nBest regards\n{{name}}"

   zip_file = FAKER.zip_file(
       options={
           "count": 9,
           "create_inner_file_func": create_inner_docx_file,
           "create_inner_file_args": {
               "content": TEMPLATE,
           },
       }
   )

*See the full example* "here"


Create a nested ZIP file
~~~~~~~~~~~~~~~~~~~~~~~~

Create a ZIP file which contains 5 ZIP files which contain 5 ZIP files
which contain 5 DOCX files.

* 5 ZIP files in the ZIP archive.

* Content is generated dynamically.

* Prefix the filenames in archive with "nested_level_1_".

* Prefix the filename of the archive itself with "nested_level_0_".

* Each of the ZIP files inside the ZIP file in their turn contains 5
  other ZIP files, prefixed with "nested_level_2_", which in their
  turn contain 5 DOCX files.

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_zip_file,
   )

   zip_file = FAKER.zip_file(
       prefix="nested_level_0_",
       options={
           "create_inner_file_func": create_inner_zip_file,
           "create_inner_file_args": {
               "prefix": "nested_level_1_",
               "options": {
                   "create_inner_file_func": create_inner_zip_file,
                   "create_inner_file_args": {
                       "prefix": "nested_level_2_",
                       "options": {
                           "create_inner_file_func": create_inner_docx_file,
                       },
                   },
               },
           },
       },
   )

*See the full example* "here"


Create a ZIP file with variety of different file types within
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 50 files in the ZIP archive (limited to DOCX, EPUB and TXT types).

* Content is generated dynamically.

* Prefix the filename of the archive itself with "zzz_archive_".

* Inside the ZIP, put all files in directory "zzz".

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_epub_file,
       create_inner_txt_file,
       fuzzy_choice_create_inner_file,
   )
   from faker_file.storages.filesystem import FileSystemStorage

   STORAGE = FileSystemStorage()

   kwargs = {"storage": STORAGE, "generator": FAKER}

   zip_file = FAKER.zip_file(
       prefix="zzz_archive_",
       options={
           "count": 50,
           "create_inner_file_func": fuzzy_choice_create_inner_file,
           "create_inner_file_args": {
               "func_choices": [
                   (create_inner_docx_file, kwargs),
                   (create_inner_epub_file, kwargs),
                   (create_inner_txt_file, kwargs),
               ],
           },
           "directory": "zzz",
       },
   )

*See the full example* "here"


Another way to create a ZIP file with variety of different file types within
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 3 files in the ZIP archive (1 DOCX, and 2 XML types).

* Content is generated dynamically.

* Filename of the archive itself is "alice-looking-through-the-
  glass.zip".

* Files inside the archive have fixed name (passed with "basename"
  argument).

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_xml_file,
       list_create_inner_file,
   )

   zip_file = FAKER.zip_file(
       basename="alice-looking-through-the-glass",
       options={
           "create_inner_file_func": list_create_inner_file,
           "create_inner_file_args": {
               "func_list": [
                   (create_inner_docx_file, {"basename": "doc"}),
                   (create_inner_xml_file, {"basename": "doc_metadata"}),
                   (create_inner_xml_file, {"basename": "doc_isbn"}),
               ],
           },
       },
   )

*See the full example* "here"

Note, that "count" argument (not shown in the example, but commonly
accepted by inner functions) will be simply ignored here.


Create an EML file consisting of TXT files with static content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 5 TXT files in the EML email (default value is 5).

* Content of all files is "Lorem ipsum".

   from faker_file.providers.eml_file import EmlFileProvider

   FAKER.add_provider(EmlFileProvider)

   eml_file = FAKER.eml_file(
       options={"create_inner_file_args": {"content": "Lorem ipsum"}}
   )

*See the full example* "here"


Create a EML file consisting of 3 DOCX files with dynamically generated content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 3 DOCX files in the EML email.

* Content is generated dynamically.

* Content is limited to 1024 chars.

* Prefix the filenames in email with "xxx_".

* Prefix the filename of the email itself with "zzz".

   from faker_file.providers.helpers.inner import create_inner_docx_file

   eml_file = FAKER.eml_file(
       prefix="zzz",
       options={
           "count": 3,
           "create_inner_file_func": create_inner_docx_file,
           "create_inner_file_args": {
               "prefix": "xxx_",
               "max_nb_chars": 1_024,
           },
       },
   )

*See the full example* "here"


Create a nested EML file
~~~~~~~~~~~~~~~~~~~~~~~~

Create a EML file which contains 5 EML files which contain 5 EML files
which contain 5 DOCX files.

* 5 EML files in the EML file.

* Content is generated dynamically.

* Prefix the filenames in EML email with "nested_level_1_".

* Prefix the filename of the EML email itself with "nested_level_0_".

* Each of the EML files inside the EML file in their turn contains 5
  other EML files, prefixed with "nested_level_2_", which in their
  turn contain 5 DOCX files.

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_eml_file,
   )

   eml_file = FAKER.eml_file(
       prefix="nested_level_0_",
       options={
           "create_inner_file_func": create_inner_eml_file,
           "create_inner_file_args": {
               "prefix": "nested_level_1_",
               "options": {
                   "create_inner_file_func": create_inner_eml_file,
                   "create_inner_file_args": {
                       "prefix": "nested_level_2_",
                       "options": {
                           "create_inner_file_func": create_inner_docx_file,
                       },
                   },
               },
           },
       },
   )

*See the full example* "here"


Create an EML file with variety of different file types within
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 10 files in the EML file (limited to DOCX, EPUB and TXT types).

* Content is generated dynamically.

* Prefix the filename of the EML itself with "zzz".

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_epub_file,
       create_inner_txt_file,
       fuzzy_choice_create_inner_file,
   )

   eml_file = FAKER.eml_file(
       prefix="zzz",
       options={
           "count": 10,
           "create_inner_file_func": fuzzy_choice_create_inner_file,
           "create_inner_file_args": {
               "func_choices": [
                   (create_inner_docx_file, kwargs),
                   (create_inner_epub_file, kwargs),
                   (create_inner_txt_file, kwargs),
               ],
           },
       },
   )

*See the full example* "here"


Create an EML file "Content-Transfer-Encoding" set to "7bit"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 10 files in the EML file (limited to DOCX, EPUB and TXT types).

* Content is generated dynamically.

* Set the "Content-Transfer-Encoding" to "7bit".

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_epub_file,
       create_inner_txt_file,
       fuzzy_choice_create_inner_file,
   )

   eml_file = FAKER.eml_file(
       cte_type="7bit",
       options={
           "count": 10,
           "create_inner_file_func": fuzzy_choice_create_inner_file,
           "create_inner_file_args": {
               "func_choices": [
                   (create_inner_docx_file, kwargs),
                   (create_inner_epub_file, kwargs),
                   (create_inner_txt_file, kwargs),
               ],
           },
       },
   )

*See the full example* "here"


Create a PDF file with predefined template containing dynamic fixtures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Content template is predefined and contains dynamic fixtures.

* Wrap lines after 80 chars.

   from faker_file.providers.pdf_file import PdfFileProvider

   FAKER.add_provider(PdfFileProvider)

   TEMPLATE = """
   {{date}} {{city}}, {{country}}

   Hello {{name}},

   {{text}} {{text}} {{text}}

   {{text}} {{text}} {{text}}

   {{text}} {{text}} {{text}}

   Address: {{address}}

   Best regards,

   {{name}}
   {{address}}
   {{phone_number}}
   """

   pdf_file = FAKER.pdf_file(content=TEMPLATE, wrap_chars_after=80)

*See the full example* "here"


Create a DOCX file with table and image using "DynamicTemplate"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When pre-defined templating and dynamic fixtures are not enough and
full control is needed, you can use "DynamicTemplate" wrapper. It
takes a list of content modifiers (tuples): "(func: Callable, kwargs:
dict)". Each callable should accept the following arguments:

* *provider*: Faker "Generator" instance or "Faker" instance.

* *document*: Document instance. Implementation specific.

* *data*: Dictionary. Used primarily for observability.

* *counter*: Integer. Index number of the content modifier.

* ***kwargs*: Dictionary. Useful to pass implementation-specific
  arguments.

The following example shows how to generate a DOCX file with
paragraph, table and image.

   from faker_file.base import DynamicTemplate
   from faker_file.contrib.docx_file import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )

   # Create a DOCX file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   docx_file = FAKER.docx_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       )
   )

*See the full example* "here"


Create a ODT file with table and image using "DynamicTemplate"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Similarly to previous section, the following example shows how to
generate an ODT file with table and image.

   from faker_file.contrib.odt_file import (
       add_page_break,
       add_paragraph,
       add_picture,
       add_table,
   )
   from faker_file.providers.odt_file import OdtFileProvider

   FAKER.add_provider(OdtFileProvider)  # Register OdtFileProvider

   # Create a ODT file with paragraph, picture, table and manual page breaks
   # in between the mentioned elements. The ``DynamicTemplate`` simply
   # accepts a list of callables (such as ``add_paragraph``,
   # ``add_page_break``) and dictionary to be later on fed to the callables
   # as keyword arguments for customising the default values.
   odt_file = FAKER.odt_file(
       content=DynamicTemplate(
           [
               (add_paragraph, {}),  # Add paragraph
               (add_page_break, {}),  # Add page break
               (add_picture, {}),  # Add picture
               (add_page_break, {}),  # Add page break
               (add_table, {}),  # Add table
               (add_page_break, {}),  # Add page break
           ]
       )
   )

*See the full example* "here"


Create a PDF using *reportlab* generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   from faker_file.providers.pdf_file.generators.reportlab_generator import (
       ReportlabPdfGenerator,
   )

   pdf_file = FAKER.pdf_file(pdf_generator_cls=ReportlabPdfGenerator)

*See the full example* "here"


Create a PDF using *pdfkit* generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note, that at the moment, "pdfkit" is the default generator. However,
you could set it explicitly as follows:

   from faker_file.providers.pdf_file.generators.pdfkit_generator import (
       PdfkitPdfGenerator,
   )

   pdf_file = FAKER.pdf_file(pdf_generator_cls=PdfkitPdfGenerator)

*See the full example* "here"


Create a graphic PDF file using *Pillow*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Graphic PDF file does not contain text. Don't use it when you need
text based content. However, sometimes you just need a valid file in
PDF format, without caring much about the content. That's where a
GraphicPdfFileProvider comes to rescue:

   from faker_file.providers.pdf_file import GraphicPdfFileProvider

   FAKER.add_provider(GraphicPdfFileProvider)

   pdf_file = FAKER.graphic_pdf_file()

*See the full example* "here"

The generated file will contain a random graphic (consisting of lines
and shapes of different colours). One of the most useful arguments
supported is "size".

   pdf_file = FAKER.graphic_pdf_file(size=(800, 800))

*See the full example* "here"


Graphic providers
~~~~~~~~~~~~~~~~~

Graphic file providers does not contain text. Don't use it when you
need text based content. However, sometimes you just need a valid
image file with graphics of a certain size. That's where graphic file
providers help.

Supported files formats are: *BMP*, *GIF*, *ICO*, *JPEG*, *PDF*,
*PNG*, *SVG* *TIFF* and *WEBP*.


Create an ICO file
""""""""""""""""""

   from faker_file.providers.ico_file import GraphicIcoFileProvider

   FAKER.add_provider(GraphicIcoFileProvider)

   ico_file = FAKER.graphic_ico_file(size=(800, 800))

*See the full example* "here"


Create a JPEG file
""""""""""""""""""

   from faker_file.providers.jpeg_file import GraphicJpegFileProvider

   FAKER.add_provider(GraphicJpegFileProvider)

   jpeg_file = FAKER.graphic_jpeg_file(size=(800, 800))

*See the full example* "here"


Create a PNG file
"""""""""""""""""

   from faker_file.providers.png_file import GraphicPngFileProvider

   FAKER.add_provider(GraphicPngFileProvider)

   png_file = FAKER.graphic_png_file(size=(800, 800))

*See the full example* "here"


Create a WEBP file
""""""""""""""""""

   from faker_file.providers.webp_file import GraphicWebpFileProvider

   FAKER.add_provider(GraphicWebpFileProvider)

   webp_file = FAKER.graphic_webp_file(size=(800, 800))

*See the full example* "here"


Create a MP3 file
~~~~~~~~~~~~~~~~~

   from faker_file.providers.mp3_file import Mp3FileProvider

   FAKER.add_provider(Mp3FileProvider)

   mp3_file = FAKER.mp3_file()

*See the full example* "here"


Create a MP3 file by explicitly specifying MP3 generator class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Google Text-to-Speech
"""""""""""""""""""""

   from faker_file.providers.mp3_file.generators.gtts_generator import (
       GttsMp3Generator,
   )

   mp3_file = FAKER.mp3_file(mp3_generator_cls=GttsMp3Generator)

*See the full example* "here"

======================================================================

You can tune arguments too:

   mp3_file = FAKER.mp3_file(
       mp3_generator_cls=GttsMp3Generator,
       mp3_generator_kwargs={
           "lang": "en",
           "tld": "co.uk",
       },
   )

*See the full example* "here"

Refer to https://gtts.readthedocs.io/en/latest/module.html#languages-
gtts-lang for list of accepted values for "lang" argument.

Refer to https://gtts.readthedocs.io/en/latest/module.html#localized-
accents for list of accepted values for "tld" argument.


Microsoft Edge Text-to-Speech
"""""""""""""""""""""""""""""

   from faker_file.providers.mp3_file.generators.edge_tts_generator import (
       EdgeTtsMp3Generator,
   )

   mp3_file = FAKER.mp3_file(mp3_generator_cls=EdgeTtsMp3Generator)

*See the full example* "here"

======================================================================

You can tune arguments too:

   mp3_file = FAKER.mp3_file(
       mp3_generator_cls=EdgeTtsMp3Generator,
       mp3_generator_kwargs={
           "voice": "en-GB-LibbyNeural",
       },
   )

*See the full example* "here"

Run "edge-tts -l" from terminal for list of available voices.


Create a MP3 file with custom MP3 generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Default MP3 generator class is "GttsMp3Generator" which uses Google
Text-to-Speech services to generate an MP3 file from given or randomly
generated text. It does not require additional services to run and the
only dependency here is the "gtts" package. You can however implement
your own custom MP3 generator class and pass it to te "mp3_file"
method in "mp3_generator_cls" argument instead of the default
"GttsMp3Generator". Read about quotas of Google Text-to-Speech
services here.

Usage with custom MP3 generator class.

   from faker_file.providers.base.mp3_generator import BaseMp3Generator
   from marytts import MaryTTS  # Imaginary `marytts` Python library

   # Define custom MP3 generator
   class MaryTtsMp3Generator(BaseMp3Generator):
       locale: str = "cmu-rms-hsmm"
       voice: str = "en_US"

       def handle_kwargs(self, **kwargs) -> None:
           # Since it's impossible to unify all TTS systems it's allowed
           # to pass arbitrary arguments to the `BaseMp3Generator`
           # constructor. Each implementation class contains its own
           # additional tuning arguments. Check the source code of the
           # implemented MP3 generators as an example.
           if "locale" in kwargs:
               self.locale = kwargs["locale"]
           if "voice" in kwargs:
               self.voice = kwargs["voice"]

       def generate(self) -> bytes:
           # Your implementation here. Note, that `self.content`
           # in this context is the text to make MP3 from.
           # `self.generator` would be the `Faker` or `Generator`
           # instance from which you could extract information on
           # active locale.
           # What comes below is pseudo implementation.
           mary_tts = MaryTTS(locale=self.locale, voice=self.voice)
           return mary_tts.synth_mp3(self.content)


   # Generate MP3 file from random text
   mp3_file = FAKER.mp3_file(
       mp3_generator_cls=MaryTtsMp3Generator,
   )

*See the full example* "here"

See exact implementation of marytts_mp3_generator in the examples.


Pick a random file from a directory given
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Create an exact copy of the randomly picked file under a different
  name.

* Prefix of the destination file would be "zzz".

* "source_dir_path" is the absolute path to the directory to pick
  files from.

   from faker_file.providers.random_file_from_dir import RandomFileFromDirProvider

   FAKER.add_provider(RandomFileFromDirProvider)

   # We assume that directory "/tmp/tmp/" exists and contains files.
   random_file = FAKER.random_file_from_dir(
       source_dir_path="/tmp/tmp/",
       prefix="zzz",
   )

*See the full example* "here"


File from path given
~~~~~~~~~~~~~~~~~~~~

* Create an exact copy of a file under a different name.

* Prefix of the destination file would be "zzz".

* "path" is the absolute path to the file to copy.

   from faker_file.providers.file_from_path import FileFromPathProvider

   FAKER.add_provider(FileFromPathProvider)

   # We assume that the file "/tmp/tmp/file.docx" exists.
   docx_file = FAKER.file_from_path(
       path="/tmp/tmp/file.docx",
       prefix="zzz",
   )

*See the full example* "here"


Generate a file of a certain size
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The only two file types for which it is easy to foresee the file size
are BIN and TXT. Note, that size of BIN files is always exact, while
for TXT it is approximate.


BIN
"""

   from faker_file.providers.bin_file import BinFileProvider

   FAKER.add_provider(BinFileProvider)

   bin_file = FAKER.bin_file(length=1024**2)  # 1 Mb
   bin_file = FAKER.bin_file(length=3 * 1024**2)  # 3 Mb
   bin_file = FAKER.bin_file(length=10 * 1024**2)  # 10 Mb

   bin_file = FAKER.bin_file(length=1024)  # 1 Kb
   bin_file = FAKER.bin_file(length=3 * 1024)  # 3 Kb
   bin_file = FAKER.bin_file(length=10 * 1024)  # 10 Kb

*See the full example* "here"


TXT
"""

   from faker_file.providers.txt_file import TxtFileProvider

   FAKER.add_provider(TxtFileProvider)

   txt_file = FAKER.txt_file(max_nb_chars=1024**2)  # 1 Mb
   txt_file = FAKER.txt_file(max_nb_chars=3 * 1024**2)  # 3 Mb
   txt_file = FAKER.txt_file(max_nb_chars=10 * 1024**2)  # 10 Mb

   txt_file = FAKER.txt_file(max_nb_chars=1024)  # 1 Kb
   txt_file = FAKER.txt_file(max_nb_chars=3 * 1024)  # 3 Kb
   txt_file = FAKER.txt_file(max_nb_chars=10 * 1024)  # 10 Kb

*See the full example* "here"


Generate a files using multiprocessing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Generate 10 DOCX files
""""""""""""""""""""""

* Use template.

* Generate 10 DOCX files.

   from multiprocessing import Pool
   from faker_file.providers.helpers.inner import create_inner_docx_file
   from faker_file.storages.filesystem import FileSystemStorage

   STORAGE = FileSystemStorage()

   # Document template
   TEMPLATE = "Hey {{name}},\n{{text}},\nBest regards\n{{name}}"

   with Pool(processes=2) as pool:
       for _ in range(10):  # Number of times we want to run our function
           pool.apply_async(
               create_inner_docx_file,
               # Apply async doesn't support kwargs. We have to pass all
               # arguments.
               [STORAGE, "mp", FAKER, None, None, TEMPLATE],
           )
       pool.close()
       pool.join()

*See the full example* "here"


Randomize the file format
"""""""""""""""""""""""""

   from faker_file.providers.helpers.inner import (
       create_inner_docx_file,
       create_inner_epub_file,
       create_inner_pdf_file,
       create_inner_txt_file,
       fuzzy_choice_create_inner_file,
   )

   kwargs = {"storage": STORAGE, "generator": FAKER, "content": TEMPLATE}

   with Pool(processes=2) as pool:
       for _ in range(10):  # Number of times we want to run our function
           pool.apply_async(
               fuzzy_choice_create_inner_file,
               [
                   [
                       (create_inner_docx_file, kwargs),
                       (create_inner_epub_file, kwargs),
                       (create_inner_pdf_file, kwargs),
                       (create_inner_txt_file, kwargs),
                   ]
               ],
           )
       pool.close()
       pool.join()

*See the full example* "here"


Generating files from existing documents using NLP augmentation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

See the following example:

   from faker_file.providers.augment_file_from_dir import (
       AugmentFileFromDirProvider,
   )

   FAKER.add_provider(AugmentFileFromDirProvider)

   # We assume that directory "/tmp/tmp/" exists and contains
   # files of `DOCX`, `EML`, `EPUB`, `ODT`, `PDF`, `RTF` or `TXT`
   # formats.
   augmented_file = FAKER.augment_file_from_dir(
       source_dir_path="/tmp/tmp/",
   )

*See the full example* "here"

Generated file will resemble text of the original document, but will
not be the same. This is useful when you don't want to test on text
generated by "Faker", but rather something that makes more sense for
your use case, still want to ensure uniqueness of the documents.

The following file types are supported:

* "DOCX"

* "EML"

* "EPUB"

* "ODT"

* "PDF"

* "RTF"

* "TXT"

======================================================================

By default, all supported files are eligible for random selection. You
could however narrow that list by providing "extensions" argument:

   # We assume that directory "/tmp/tmp/" exists and contains
   # files of `DOCX` and `ODT` formats.
   augmented_file = FAKER.augment_file_from_dir(
       source_dir_path="/tmp/tmp/",
       extensions={"docx", "odt"},  # Pick only DOCX or ODT
   )

*See the full example* "here"

======================================================================

Actual augmentation of texts is delegated to an abstraction layer of
text augmenters. Currently, two augmenters are implemented. Default
one is based on >>`textaugment`_<< (which is in its' turn based on
nltk) is very lightweight and speedy, but produces less accurate
results. Another one is based on nlpaug, which is way more
sophisticated, but at the cost of speed.


nlpaug augmenter
~~~~~~~~~~~~~~~~

By default "bert-base-multilingual-cased" model is used, which is
pretrained on the top 104 languages with the largest Wikipedia using a
masked language modeling (MLM) objective. If you want to use a
different model, specify the proper identifier in the "model_path"
argument. Some well working options for "model_path" are:

* "bert-base-multilingual-cased"

* "bert-base-multilingual-uncased"

* "bert-base-cased"

* "bert-base-uncased"

* "bert-base-german-cased"

* "GroNLP/bert-base-dutch-cased"

   from faker_file.providers.augment_file_from_dir.augmenters import (
       nlpaug_augmenter,
   )

   # We assume that directory "/tmp/tmp/" exists and contains
   # files of `DOCX`, `EML`, `EPUB`, `ODT`, `PDF`, `RTF` or `TXT`
   # formats.
   augmented_file = FAKER.augment_file_from_dir(
       source_dir_path="/tmp/tmp/",
       text_augmenter_cls=nlpaug_augmenter.ContextualWordEmbeddingsAugmenter,
       text_augmenter_kwargs={
           "model_path": "bert-base-cased",
           "action": "substitute",  # or "insert"
       },
   )

*See the full example* "here"

Refer to "nlpaug" docs and check *Textual augmenters* examples.


textaugment augmenter
~~~~~~~~~~~~~~~~~~~~~

   from faker_file.providers.augment_file_from_dir.augmenters import (
       textaugment_augmenter,
   )

   # We assume that directory "/tmp/tmp/" exists and contains
   # files of `DOCX`, `EML`, `EPUB`, `ODT`, `PDF`, `RTF` or `TXT`
   # formats. Valid values for `action` are: "random_deletion",
   # "random_insertion", "random_swap" and "synonym_replacement" (default).
   augmented_file = FAKER.augment_file_from_dir(
       source_dir_path="/tmp/tmp/",
       text_augmenter_cls=textaugment_augmenter.EDATextaugmentAugmenter,
       text_augmenter_kwargs={
           "action": "synonym_replacement",
       },
   )

*See the full example* "here"


Using *raw=True* features in tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you pass "raw=True" argument to any provider or inner function,
instead of creating a file, you will get "bytes" back (or to be
totally correct, "bytes"-like object "BytesValue", which is basically
bytes enriched with meta-data). You could then use the "bytes" content
of the file to build a test payload as shown in the example test
below:

   class UploadTestCase(TestCase):
       """Upload test case."""

       def test_create_docx_upload(self) -> None:
           """Test create an Upload."""
           url = reverse("api:upload-list")

           raw = FAKER.docx_file(raw=True)
           test_file = BytesIO(raw)
           test_file.name = os.path.basename(raw.data["filename"])

           payload = {
               "name": FAKER.word(),
               "description": FAKER.paragraph(),
               "file": test_file,
           }

           response = self.client.post(url, payload, format="json")

           # Test if request is handled properly (HTTP 201)
           self.assertEqual(response.status_code, HTTP_201_CREATED)

           test_upload = Upload.objects.get(id=response.data["id"])

           # Test if the name is properly recorded
           self.assertEqual(str(test_upload.name), payload["name"])

           # Test if file name recorded properly
           self.assertEqual(str(test_upload.file.name), test_file.name)

*See the full example* "here"


Create a HTML file from predefined template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to generate a file in a format that is not (yet)
supported, you can try to use "GenericFileProvider". In the following
example, an HTML file is generated from a template.

   from faker_file.providers.generic_file import GenericFileProvider

   FAKER.add_provider(GenericFileProvider)

   generic_file = FAKER.generic_file(
       content="<html><body><p>{{text}}</p></body></html>",
       extension="html",
   )

*See the full example* "here"


Working with storages
~~~~~~~~~~~~~~~~~~~~~


AWS S3 storage
""""""""""""""

   from faker_file.storages.aws_s3 import AWSS3Storage

   AWS_S3_STORAGE = AWSS3Storage(
       bucket_name="your-bucket-name",
       root_path="",
       rel_path="",
   )

   txt_file = FAKER.txt_file(storage=AWS_S3_STORAGE)

*See the full example* "here"

======================================================================

Depending on the ORM or framework you're using, you might want to
tweak the "root_path" and "rel_path" values. Especially if you store
files in directories (like "your-bucket-name/path/to/the/file.ext").

For instance, if you use "Django" and "django-storages", and want to
store the files inside "/user/uploads" directory the following would
be correct:

   AWS_S3_STORAGE = AWSS3Storage(
       bucket_name="your-bucket-name",
       root_path="",
       rel_path="user/uploads",
   )

*See the full example* "here"


Google Cloud Storage
""""""""""""""""""""

   from faker_file.storages.google_cloud_storage import GoogleCloudStorage

   GC_STORAGE = GoogleCloudStorage(
       bucket_name="your-bucket-name",
       root_path="",
       rel_path="",
   )

   # txt_file = FAKER.txt_file(storage=GC_STORAGE)

*See the full example* "here"

======================================================================

Similarly to "AWSS3Storage", if you use "Django" and "django-
storages", and want to store the files inside "/user/uploads"
directory the following would be correct:

   GC_STORAGE = GoogleCloudStorage(
       bucket_name="your-bucket-name",
       root_path="",
       rel_path="user/uploads",
   )

*See the full example* "here"


SFTP storage
""""""""""""

   from faker_file.storages.sftp_storage import SFTPStorage

   SFTP_STORAGE = SFTPStorage(
       host="your-sftp-host.domain",
       port=22,
       username="your-sftp-username",
       password="your-sftp-password",
       root_path="/dir-name",
   )

   # txt_file = FAKER.txt_file(storage=SFTP_STORAGE)

*See the full example* "here"


When using with "Django" (and "factory_boy")
--------------------------------------------

When used with Django (to generate fake data with "factory_boy"
factories), the "root_path" argument of the correspondent file storage
shall be provided. Otherwise (although no errors will be triggered)
the generated files will reside outside the "MEDIA_ROOT" directory (by
default in "/tmp/" on Linux) and further operations with those files
through Django will cause "SuspiciousOperation" exception.

======================================================================


Basic example
~~~~~~~~~~~~~


Imaginary "Django" model
""""""""""""""""""""""""

   class Upload(models.Model):
       """Upload model."""

       name = models.CharField(max_length=255, unique=True)
       description = models.TextField(null=True, blank=True)

       # File
       file = models.FileField(null=True)

*See the full example* "here"


Correspondent "factory_boy" factory
"""""""""""""""""""""""""""""""""""

   from django.conf import settings
   from factory import Faker, Trait
   from factory.django import DjangoModelFactory

   # Import all providers we want to use
   from faker_file.providers.bin_file import BinFileProvider
   from faker_file.providers.csv_file import CsvFileProvider
   from faker_file.providers.docx_file import DocxFileProvider
   from faker_file.providers.eml_file import EmlFileProvider
   from faker_file.providers.epub_file import EpubFileProvider
   from faker_file.providers.ico_file import IcoFileProvider
   from faker_file.providers.jpeg_file import JpegFileProvider
   from faker_file.providers.mp3_file import Mp3FileProvider
   from faker_file.providers.ods_file import OdsFileProvider
   from faker_file.providers.odt_file import OdtFileProvider
   from faker_file.providers.pdf_file import PdfFileProvider
   from faker_file.providers.png_file import PngFileProvider
   from faker_file.providers.pptx_file import PptxFileProvider
   from faker_file.providers.rtf_file import RtfFileProvider
   from faker_file.providers.svg_file import SvgFileProvider
   from faker_file.providers.txt_file import TxtFileProvider
   from faker_file.providers.webp_file import WebpFileProvider
   from faker_file.providers.xlsx_file import XlsxFileProvider
   from faker_file.providers.zip_file import ZipFileProvider

   # Import file storage, because we need to customize things in order for it
   # to work with Django.
   from faker_file.storages.filesystem import FileSystemStorage

   from upload.models import Upload

   # Add all providers we want to use
   Faker.add_provider(BinFileProvider)
   Faker.add_provider(CsvFileProvider)
   Faker.add_provider(DocxFileProvider)
   Faker.add_provider(EmlFileProvider)
   Faker.add_provider(EpubFileProvider)
   Faker.add_provider(IcoFileProvider)
   Faker.add_provider(JpegFileProvider)
   Faker.add_provider(Mp3FileProvider)
   Faker.add_provider(OdsFileProvider)
   Faker.add_provider(OdtFileProvider)
   Faker.add_provider(PdfFileProvider)
   Faker.add_provider(PngFileProvider)
   Faker.add_provider(PptxFileProvider)
   Faker.add_provider(RtfFileProvider)
   Faker.add_provider(SvgFileProvider)
   Faker.add_provider(TxtFileProvider)
   Faker.add_provider(WebpFileProvider)
   Faker.add_provider(XlsxFileProvider)
   Faker.add_provider(ZipFileProvider)

   # Define a file storage. When working with Django and FileSystemStorage
   # you need to set the value of `root_path` argument to
   # `settings.MEDIA_ROOT`.
   STORAGE = FileSystemStorage(root_path=settings.MEDIA_ROOT, rel_path="tmp")


   class UploadFactory(DjangoModelFactory):
       """Upload factory."""

       name = Faker("text", max_nb_chars=100)
       description = Faker("text", max_nb_chars=1000)

       class Meta:
           model = Upload

       class Params:
           bin_file = Trait(file=Faker("bin_file", storage=STORAGE))
           csv_file = Trait(file=Faker("csv_file", storage=STORAGE))
           docx_file = Trait(file=Faker("docx_file", storage=STORAGE))
           eml_file = Trait(file=Faker("eml_file", storage=STORAGE))
           epub_file = Trait(file=Faker("epub_file", storage=STORAGE))
           ico_file = Trait(file=Faker("ico_file", storage=STORAGE))
           jpeg_file = Trait(file=Faker("jpeg_file", storage=STORAGE))
           mp3_file = Trait(file=Faker("mp3_file", storage=STORAGE))
           ods_file = Trait(file=Faker("ods_file", storage=STORAGE))
           odt_file = Trait(file=Faker("odt_file", storage=STORAGE))
           pdf_file = Trait(file=Faker("pdf_file", storage=STORAGE))
           png_file = Trait(file=Faker("png_file", storage=STORAGE))
           pptx_file = Trait(file=Faker("pptx_file", storage=STORAGE))
           rtf_file = Trait(file=Faker("rtf_file", storage=STORAGE))
           svg_file = Trait(file=Faker("svg_file", storage=STORAGE))
           txt_file = Trait(file=Faker("txt_file", storage=STORAGE))
           webp_file = Trait(file=Faker("webp_file", storage=STORAGE))
           xlsx_file = Trait(file=Faker("xlsx_file", storage=STORAGE))
           zip_file = Trait(file=Faker("zip_file", storage=STORAGE))

And then somewhere in your code:

   UploadFactory(bin_file=True)  # Upload with BIN file
   UploadFactory(docx_file=True)  # Upload with DOCX file
   UploadFactory(jpeg_file=True)  # Upload with JPEG file
   UploadFactory(zip_file=True)  # Upload with ZIP file

*See the full example* "here"

======================================================================


Randomize provider choice
~~~~~~~~~~~~~~~~~~~~~~~~~

   from random import choice
   from factory import Faker, LazyAttribute, Trait
   from faker import Faker as OriginalFaker

   FAKER = OriginalFaker()
   FAKER.add_provider(BinFileProvider)
   FAKER.add_provider(CsvFileProvider)
   FAKER.add_provider(DocxFileProvider)
   FAKER.add_provider(EmlFileProvider)
   FAKER.add_provider(EpubFileProvider)
   FAKER.add_provider(IcoFileProvider)
   FAKER.add_provider(JpegFileProvider)
   FAKER.add_provider(Mp3FileProvider)
   FAKER.add_provider(OdsFileProvider)
   FAKER.add_provider(OdtFileProvider)
   FAKER.add_provider(PdfFileProvider)
   FAKER.add_provider(PngFileProvider)
   FAKER.add_provider(PptxFileProvider)
   FAKER.add_provider(RtfFileProvider)
   FAKER.add_provider(SvgFileProvider)
   FAKER.add_provider(TxtFileProvider)
   FAKER.add_provider(WebpFileProvider)
   FAKER.add_provider(XlsxFileProvider)
   FAKER.add_provider(ZipFileProvider)


   def random_file_generator(*args, **kwargs):
       random_provider = choice(
           [
               "bin_file",
               "csv_file",
               "docx_file",
               "eml_file",
               "epub_file",
               "ico_file",
               "jpeg_file",
               "mp3_file",
               "ods_file",
               "odt_file",
               "pdf_file",
               "png_file",
               "pptx_file",
               "rtf_file",
               "svg_file",
               "txt_file",
               "webp_file",
               "xlsx_file",
               "zip_file",
           ]
       )
       func = getattr(FAKER, random_provider)
       return func(storage=STORAGE)


   class UploadFactory(DjangoModelFactory):
       """Upload factory."""

       name = Faker("text", max_nb_chars=100)
       description = Faker("text", max_nb_chars=1000)

       class Meta:
           model = Upload

       class Params:
           random_file = Trait(file=LazyAttribute(random_file_generator))

And then somewhere in your code:

   # Upload with randon file
   upload = UploadFactory(random_file=True)

*See the full example* "here"


Use a different locale
~~~~~~~~~~~~~~~~~~~~~~

       Faker.add_provider(OdtFileProvider)
       upload = UploadFactory()

*See the full example* "here"


Other Django usage examples
~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Faker example with AWS S3 storage**

   from faker import Faker
   from faker_file.storages.aws_s3 import AWSS3Storage

   STORAGE = AWSS3Storage(
       bucket_name=settings.AWS_STORAGE_BUCKET_NAME,
       root_path="",
       rel_path="",
   )

   FAKER = Faker()
   FAKER.add_provider(PdfFileProvider)

   pdf_file = FAKER.pdf_file(storage=STORAGE)

*See the full example* "here"

======================================================================

**factory-boy example with AWS S3 storage**

   from factory import Faker
   from faker_file.providers.pdf_file import PdfFileProvider
   from faker_file.storages.aws_s3 import AWSS3Storage

   STORAGE = AWSS3Storage(
       bucket_name=settings.AWS_STORAGE_BUCKET_NAME,
       root_path="",
       rel_path="",
   )

   Faker.add_provider(PdfFileProvider)


   class UploadFactory(DjangoModelFactory):
       name = Faker("word")
       description = Faker("text")
       file = Faker("pdf_file", storage=STORAGE)

       class Meta:
           model = Upload


   # Usage example
   upload = UploadFactory()

*See the full example* "here"

======================================================================

**Flexible storage selection**

   from django.core.files.storage import default_storage
   from faker_file.storages.aws_s3 import AWSS3Storage
   from faker_file.storages.filesystem import FileSystemStorage
   from storages.backends.s3boto3 import S3Boto3Storage

   # Faker doesn't know anything about Django. That's why, if we want to
   # support remote storages, we need to manually check which file storage
   # backend is used. If `Boto3` storage backend (of the `django-storages`
   # package) is used we use the correspondent `AWSS3Storage` class of the
   # `faker-file`.
   # Otherwise, fall back to native file system storage (`FileSystemStorage`)
   # of the `faker-file`.
   if isinstance(default_storage, S3Boto3Storage):
       STORAGE = AWSS3Storage(
           bucket_name=settings.AWS_STORAGE_BUCKET_NAME,
           credentials={
               "key_id": settings.AWS_ACCESS_KEY_ID,
               "key_secret": settings.AWS_SECRET_ACCESS_KEY,
           },
           root_path="",
           rel_path="tmp",
       )
   else:
       STORAGE = FileSystemStorage(
           root_path=settings.MEDIA_ROOT,
           rel_path="tmp",
       )

*See the full example* "here"

======================================================================


CLI
===

It's possible to generate files from CLI.

Note:

  For using CLI you should install all common dependencies (including
  underlying system dependencies).

Install using pipx (recommended):

   pipx install faker-file[common]

Install using "pip".

   pip install faker-file[common] --user


List available provider options
-------------------------------

   faker-file --help

Output:

   usage: faker-file [-h]
     {generate-completion,version,bin_file,csv_file,docx_file,eml_file,
      epub_file,generic_file,graphic_ico_file,graphic_jpeg_file,
      graphic_pdf_file,graphic_png_file,graphic_webp_file,ico_file,
      jpeg_file,mp3_file,odp_file,ods_file,odt_file,pdf_file,png_file,
      pptx_file,rtf_file,svg_file,tar_file,txt_file,webp_file,xlsx_file,
      xml_file,zip_file}
         ...

   CLI for the faker-file package.

   positional arguments:
     {generate-completion,version,bin_file,csv_file,docx_file,eml_file,
      epub_file,generic_file,graphic_ico_file,graphic_jpeg_file,
      graphic_pdf_file,graphic_png_file,graphic_webp_file,ico_file,
      jpeg_file,mp3_file,odp_file,ods_file,odt_file,pdf_file,png_file,
      pptx_file,rtf_file,svg_file,tar_file,txt_file,webp_file,xlsx_file,
      xml_file,zip_file}

                               Available file providers.
       generate-completion     Generate bash completion file.
       version                 Print version.
       bin_file                Generate a bin file.
       csv_file                Generate a csv file.
       docx_file               Generate a docx file.
       eml_file                Generate a eml file.
       epub_file               Generate a epub file.
       generic_file            Generate a generic file.
       graphic_ico_file        Generate a graphic_ico file.
       graphic_jpeg_file       Generate a graphic_jpeg file.
       graphic_pdf_file        Generate a graphic_pdf file.
       graphic_png_file        Generate a graphic_png file.
       graphic_webp_file       Generate a graphic_webp file.
       ico_file                Generate a ico file.
       jpeg_file               Generate a jpeg file.
       mp3_file                Generate a mp3 file.
       odp_file                Generate a odp file.
       ods_file                Generate a ods file.
       odt_file                Generate a odt file.
       pdf_file                Generate a pdf file.
       png_file                Generate a png file.
       pptx_file               Generate a pptx file.
       rtf_file                Generate a rtf file.
       svg_file                Generate a svg file.
       tar_file                Generate a tar file.
       txt_file                Generate a txt file.
       webp_file               Generate a webp file.
       xlsx_file               Generate a xlsx file.
       xml_file                Generate a xml file.
       zip_file                Generate a zip file.

   options:
     -h, --help            show this help message and exit


List options for a certain provider
-----------------------------------

   faker-file docx_file --help

Output:

   usage: faker-file docx_file [-h] [--prefix PREFIX] [--max_nb_chars MAX_NB_CHARS] [--wrap_chars_after WRAP_CHARS_AFTER] [--content CONTENT] [--nb_files NB_FILES]

   options:
     -h, --help            show this help message and exit
     --prefix PREFIX       prefix (default: None)
     --max_nb_chars MAX_NB_CHARS
                           max_nb_chars (default: 10000)
     --wrap_chars_after WRAP_CHARS_AFTER
                           wrap_chars_after (default: None)
     --content CONTENT     content (default: None)
     --nb_files NB_FILES   number of files to generate (default: 1)


Generate a file using certain provider
--------------------------------------

   faker-file docx_file

Output:

   Generated docx_file file: tmp/tmpva0mp3lp.docx


Shell auto-completion
---------------------

First, generate shell auto-completion file.

   faker-file generate-completion

Then, source the generated file:

   source ~/faker_file_completion.sh

Now you can use auto-completion. Simply type faker-file [tab-tab] to
see the list of available options:

   $ faker-file
   bin_file             graphic_jpeg_file    ods_file             txt_file
   csv_file             graphic_pdf_file     odt_file             version
   docx_file            graphic_png_file     pdf_file             webp_file
   eml_file             graphic_webp_file    png_file             xlsx_file
   epub_file            ico_file             pptx_file            xml_file
   generate-completion  jpeg_file            rtf_file             zip_file
   generic_file         mp3_file             svg_file
   graphic_ico_file     odp_file             tar_file

It works with sub options too:

   $ faker-file docx_file --
   --content    --max_nb_chars    --prefix    --wrap_chars_after    --nb_files

To update the completion script, simply run the "generate-completion"
command again and source the "~/faker_file_completion.sh" as already
shown above.

======================================================================


Security Policy
===============


Reporting a Vulnerability
-------------------------

**Do not report security issues on GitHub!**

Please report security issues by emailing Artur Barseghyan
<artur.barseghyan@gmail.com>.


Supported Versions
------------------

**Make sure to use the latest version.**

The two most recent "faker-file" release series receive security
support.

For example, during the development cycle leading to the release of
"faker-file" 0.17.x, support will be provided for "faker-file" 0.16.x.

Upon the release of "faker-file" 0.18.x, security support for "faker-
file" 0.16.x will end.

   ┌─────────────────┬────────────────┐
   │ Version         │ Supported      │
   ├─────────────────┼────────────────┤
   │ 0.18.x          │ Yes            │
   ├─────────────────┼────────────────┤
   │ 0.17.x          │ Yes            │
   ├─────────────────┼────────────────┤
   │ < 0.17          │ No             │
   └─────────────────┴────────────────┘

======================================================================


Contributor guidelines
======================


Developer prerequisites
-----------------------


pre-commit
~~~~~~~~~~

Refer to pre-commit for installation instructions.

TL;DR:

   pip install pipx --user  # Install pipx
   pipx install pre-commit  # Install pre-commit
   pre-commit install  # Install pre-commit hooks

Installing pre-commit will ensure you adhere to the project code
quality standards.


Code standards
--------------

ruff and doc8 will be automatically triggered by pre-commit.

ruff is configured to do the job of black and isort as well, so all
the standards apply.

Still, if you want to run checks manually:

   make pre-commit


Requirements
------------

Requirements are compiled using uv.

   make compile_requirements
   make compile_requirements_upgrade


Virtual environment
-------------------

You are advised to work in virtual environment.

TL;DR:

   python -m venv env
   make install


Documentation
-------------

Check documentation.


Testing
-------

Check testing.

If you introduce changes or fixes, make sure to test them locally
using all supported environments. For that use tox.

   tox

For quick testing in current environment only:

   make test

In any case, GitHub Actions will catch potential errors, but using tox
speeds things up.


Pull requests
-------------

You can contribute to the project by making a pull request.

For example:

* To fix documentation typos.

* To improve documentation (for instance, to add new recipe or fix an
  existing recipe that doesn't seem to work).

* To introduce a new feature (for instance, add support for a non-
  supported file type).

**Good to know:**

* Test suite makes extensive use of parametrization. Make sure you
  have added your changes in the right place.

**General list to go through:**

* Does your change require documentation update?

* Does your change require update to tests?

* Did you test both Latin and Unicode characters?

* Does your change rely on third-party cloud based service? If so,
  please make sure it's added to tests that should be retried a couple
  of times. Example: "@pytest.mark.flaky(reruns=5)".

**When fixing bugs (in addition to the general list):**

* Make sure to add regression tests.

**When adding a new feature (in addition to the general list):**

* Check the licenses of added dependencies carefully and make sure to
  list them in >>`prerequisites`_<<.

* Make sure to update the documentation (check whether the
  installation, features, recipes and quick start require changes).


Questions
---------

Questions can be asked on GitHub discussions.


Issues
------

For reporting a bug or filing a feature request use GitHub issues.

**Do not report security issues on GitHub**. Check the support
section.

======================================================================


Release history and notes
=========================

Sequence based identifiers are used for versioning (schema follows
below):

   major.minor[.revision]

* It's always safe to upgrade within the same minor version (for
  example, from 0.3 to 0.3.4).

* Minor version changes might be backwards incompatible. Read the
  release notes carefully before upgrading (for example, when
  upgrading from 0.3.4 to 0.4).

* All backwards incompatible changes are mentioned in this document.


0.18.4
------

2025-05-09

* Enhance customisation of "eml_file" provider.


0.18.3
------

2025-05-07

* Correct guessing of mimetypes in "eml_file" provider.


0.18.2
------

2025-05-03

* Switch to pytest-codeblock for testing documentation codeblocks.

* Move pytest, mypy and coverage configuration to *pyproject.toml*.

* Update jsphinx to the latest version.


0.18.1
------

2025-03-12

* Tested against Django 5.1.

* Minor documentation fixes.


0.18
----

2025-03-10

* Drop Python 3.7 and 3.8 support.

* Add Python 3.12 support.

* Add "pathy==0.11.x" support.

* Prepare to support more cloud-pathlib alternatives (like
  cloudpathlib), next to existing >>`pathy`_<<.


0.17.14
-------

2024-11-14

* Minor fixes.


0.17.13
-------

2024-10-30

* Upgrade *Pillow* related code to work with *Pillow*>=9.1.0 (tested
  with 10.x and 11.x).

* Drop EOL Python 3.8 support.


0.17.12
-------

2024-09-10

* Minor fixes.


0.17.11
-------

2023-11-20

* Minor documentation fixes.


0.17.10
-------

2023-11-19

* Make "text_extractor_cls" and "text_augmenter_cls" arguments of the
  "AugmentFileFromDirProvider" provider access string values (to load
  requested class from path given).

* Add "TextaugmentAugmenter" based on >>`textaugment`_<< package (very
  lightweight) and make it a default text augmenter.

* Minor documentation fixes.

* Optimized GitHub CI.


0.17.9
------

2023-10-10

* Improvements and fixes in the documentation.

* Announcing feature plans to change default PDF and Image generators
  to >>`Pillow`_<< based ones, instead of >>`wkhtmltopdf`_<< in
  version 0.18.


0.17.8
------

2023-09-21

Note:

  This release is dedicated to the victims of the war in Artsakh
  (Nagorno-Karabakh), a land now lost to its native inhabitants
  (Armenians). Following a grueling nine-month blockade, Azerbaijan
  initiated another military onslaught on September 19, 2023. The
  already weakened and outnumbered forces of Artsakh could no longer
  mount an effective resistance.

* Added support for "DynamicTemplate" to all non-graphic image
  providers. That means, that you can produce images with text,
  tables, various headings and other images. Correspondent snippets
  are implemented for all supported image generators; namely
  reportlab, WeasyPrint and >>`Pillow`_<<.


0.17.7
------

2023-09-12

* Added "GTTS_MP3_GENERATOR" and "EDGE_TTS_MP3_GENERATOR" to the
  "mp3_file" provider import options.


0.17.6
------

2023-09-09

* Added "add_paragraph", "add_picture", "add_heading_h1" and other
  heading helpers to "pil_snippets" contrib module.


0.17.5
------

2023-08-22

Note:

  This release might introduces minor backwards incompatible changes
  only if you have written own- or customized existing- image
  providers and used them in combination with WeasyPrint-based image
  generator. A new property named "image_format" has been added to all
  image-based providers and the "WeasyPrintImageGenerator" is using
  that instead of formerly used "extension" property.

* Added "PilImageGenerator" (for text-to-image).

* Added "PilPdfGenerator" (for text-to-image).


0.17.4
------

2023-08-18

Note:

  Release is dedicated to the victims and de-facto hostages of the
  Blockade of the Republic of Artsakh. Have you ever heard of Armenian
  genocide? It's happening again. For more than 8 months, Azerbaijan
  has launched an illegal blockade of the Republic of Artsakh,
  including critical civilian infrastructure such as gas, electricity
  and roads connecting Armenia and Artaskh. Shortages of essential
  goods – including electricity, fuel, and water reserves – are
  widespread and emergency reserves are being rationed. The blockade
  has resulted in significant medical and food shortages in Artsakh,
  leading to increased health complications, as reported by Artsakh
  Healthcare ministry.

     * Deaths due to cardiovascular diseases doubled in the first
       seven months of the year, with a particular surge in July-
       August.

     * Deaths from malignant tumors rose by 15.9% over the same period
       due to lack of medications and medical aid.

     * New cases of stroke and heart attacks increased by 26% and 9.7%
       respectively.

     * Newly diagnosed cases of malignant tumors rose by 24.3%.

     * Around 90% of monitored pregnant women developed anemia from
       poor nutrition and medication shortages.

     * While overall abortion numbers remained stable, medically
       indicated abortions quadrupled in July due to factors like
       stress and inadequate nutrition.

     * Reports of fainting surged by 91% in July-August.

     * Emergency calls for high blood pressure saw a 5.6-fold increase
       in July-August.

  The dire health outcomes are attributed to the blockade's impact,
  including medication shortages, stress, disrupted medical
  procedures, and restricted healthcare access. The Artsakh Health
  Ministry warns of further deterioration if the blockade continues,
  emphasizing the systemic challenges in healthcare delivery due to
  the blockade.

* Added "AugmentRandomImageFromDirProvider" and
  "AugmentImageFromPathProvider" providers for basic image
  augmentation.

* Added "storage" to metadata for all providers for easy clean-up of
  files.

* Added "unlink" method to all storages for easy clean-up of files.

* Added "FileRegistry" to keep track of all files created and
  introduce functionality for cleaning up the files.

* Stop testing against Python 3.7.


0.17.3
------

2023-08-02

Note:

  In memory of Sinead O'Connor.

* Allow to pass "image" argument ("bytes") to the contrib
  "add_picture" functions.

* Documentation improvements.


0.17.2
------

2023-07-25

* Added "JSON" file provider.


0.17.1
------

2023-07-21

* Added "WeasyPrintImageGenerator" image generator class based on
  WeasyPrint and pdf2image packages.

* Added "BMP", "TIFF" and "GIF" file providers (both text-to-image and
  graphic ones). Note, that above mentioned text-to-image providers
  are using "WeasyPrintImageGenerator" as a default image generator
  class, since "ImagekitImageGenerator" class isn't capable of
  supporting the above mentioned file formats.

* Added more helper functions for "DynamicTemplate" use for ODT, PDF
  and DOCX file providers to support h1, h2, h3, h4, h5 and h6
  headings.


0.17
----

2023-07-12

Note:

  Release is dedicated to the victims and de-facto hostages of the
  Blockade of the Republic of Artsakh. Have you ever heard of Armenian
  genocide? It's happening again and the world silently watches.

* Introducing graphic image providers. Prior to this release, images
  have been created using text-to-image solutions. Sometimes it's just
  handy to have a graphic image. Therefore, a number of graphic image
  file providers have been created (including inner functions
  support). The following graphic file providers have been added:
  "GraphicIcoFileProvider", "GraphicJpegFileProvider",
  "GraphicPdfFileProvider", "GraphicPngFileProvider" and
  "GraphicWebpFileProvider" to support creation of graphic "ICO",
  "JPEG", "PDF", "PNG" and "WEBP" files.

* The previously mentioned text-to-image rendering has been delegated
  to image generators. Default generator is still based on the imgkit,
  but the change makes it possible to use custom generators.


0.16.4
------

2023-07-01

* Documentation improvements. Added a dedicated section for creating
  ODT files.

* Adding "add_paragraph" and "add_page_break" to "ODT" contrib module.


0.16.3
------

2023-06-30

* Documentation improvements. Added a dedicated section for creating
  PDF files. Added a dedicated section for creating DOCX files.

* Adding "add_paragraph" and "add_page_break" to "DOCX" contrib
  module.


0.16.2
------

2023-06-28

* Moving some of the snippets from tests to a "contrib" module to
  improve usability. The snippets are generic enough to be used in
  tests and if you don't like the way they work, you could always make
  a new one. New snippets to insert page breaks and paragraphs into
  PDF (using both pdfkit and reportlab generators) have been added.


0.16.1
------

2023-06-23

* Better error handling in CLI.


0.16
----

2023-06-21

Note:

  This release is dedicated to my beloved son - Tigran, who turned 11!

Note:

  This release introduces minor backwards incompatible changes.

* Minor improvements in PDF generation. If you have been using
  "DynamicTemplate" to generate complex PDFs, you are likely affected
  by the change. Make sure to at least add an additional argument
  named "generator" to the functions passed to the "DynamicTemplate"
  class. See the example below:

  Old:

     "def add_pb(provider, story, data, counter, **kwargs):"

  New:

     "def add_pb(provider, generator, story, data, counter,
     **kwargs):"

* Add code examples of how to generate a PDF with 100 pages with both
  "PdfkitPdfGenerator" and "ReportlabPdfGenerator" PDF generator
  classes.

* Add "version" CLI command.

* Add "generate-completion" and "version" commands to the CLI auto-
  completion.


0.15.5
------

2023-06-18

* Minor fixes and documentation improvements.


0.15.4
------

2023-06-15

* Improved "SFTPStorage" tests.

* Stop testing against Python 3.7.

* Stop testing against Django 4.0.


0.15.3
------

2023-06-14

* Add "SFTPStorage" and correspondent tests.


0.15.2
------

2023-06-08

* Add optional "subject" argument to the "EmlFileProvider". Update
  tests accordingly.

* Add data integrity tests.


0.15.1
------

2023-06-06

* Added "FileFromPathProvider" provider, which simply picks a file
  from path given. Add correspondent "create_inner_file_from_path"
  inner function.


0.15
----

2023-06-05

* Added "format_func" argument to most of the providers. This allows
  to control which formatter function will be used as a default
  formatter. Previously it has been
  "faker.provider.Python.pystr_format", which has been changed to
  "faker.provider.Python.parse", since the latter is more convenient
  (as it does not transform characters like "?", "!", "#" into
  something else using "bothify" method). To revert this behaviour,
  make sure to pass a callable function
  "faker_file.base.pystr_format_func" in "format_func" argument to
  each correspondent provider or inner function.

* Added "create_inner_random_file_from_dir" inner function.

* Tested against Django 4.2.

* Stop testing against Django 2.2.


0.14.5
------

2023-05-11

* Minor fixes in "xml_file" provider.


0.14.4
------

2023-05-11

* Changed type of "data_columns" for "xml_file" provider from
  "Sequence[Tuple[str, str]]" to "Dict[str, str]".

* In the "pdf_file" provider, changed default value of
  "pdf_generator_cls" from concrete "PdfkitPdfGenerator" value to its'
  string representation faker_file.providers.pdf_file.generators.pdfk
  it_generator.PdfkitPdfGenerator.

* In the "mp3_file" provider, changed default value of
  "mp3_generator_cls" from concrete "GttsMp3Generator" value to its'
  string representation faker_file.providers.mp3_file.generators.gtts
  _generator.GttsMp3Generator.


0.14.3
------

2023-05-10

* Minor fixes in the "GenericFileProvider".


0.14.2
------

2023-05-09

* Add "create_inner_generic_file" inner function.

* Add "generic_file" support to CLI.


0.14.1
------

2023-05-08

* Add support for "list_create_inner_file"-like functions to the "EML"
  file provider. If you are using CLI and CLI-completion, make sure to
  re-generate the completion file.

* Add "GenericFileProvider" provider to support generic file types.


0.14
----

2023-05-07

Note:

  This release introduces minor backwards incompatible changes.

* A new argument "basename" has been added to all providers, inner
  functions and storage classes. If you have customized things or
  created your own providers, make sure to make appropriate changes in
  your code. See the source code for more implementation examples. If
  you are using CLI and CLI-completion, make sure to re-generate the
  completion file.

* A new inner function "list_create_inner_file" has been added, using
  which it's possible to create just a list of given files (ignoring
  "count" value) using given arguments. The amount of files is
  determined by the "func_list" (each pair "(Callable, kwargs)"
  corresponds to a single file. Both "ZipFileProvider" and
  "TarFileProvider" have been altered to reflect these changes.

* Added to support for "XML" files through "XmlFileProvider".


0.13
----

2023-05-05

Note:

  This release introduces minor backwards incompatible changes.

* Display full path to the created file in the CLI.

* Added "DynamicTemplate" support for "PDF" file. The "generate"
  method of the "BasePdfGenerator" and classes derived from it, got
  two new arguments: "data" ("Dict[str, Any]"), and "provider"
  ("Union[Faker, Generator, Provider]"). If you have implemented
  custom generators for "PDF" ("pdf_file" provider), make sure to
  reflect mentioned changes in your code.


0.12.6
------

2023-05-02

* Added "DynamicTemplate" support for "DOCX" and "ODT" files.


0.12.5
------

2023-04-24

Note:

  In memory of the victims of the Armenian Genocide.

* Expose "mp3_generator_cls" and "pdf_generator_cls" CLI options for
  "mp3_file" and "pdf_file" respectively.

* Add "num_files" CLI option for all providers.


0.12.4
------

2023-04-22

* Make it possible to load classes from strings for passing as
  arguments to "mp3_file" and "pdf_file" providers.


0.12.3
------

2023-04-21

* Fixes in CLI options.


0.12.2
------

2023-04-20

* Fixes in CLI options.


0.12.1
------

2023-04-19

* Added CLI options.


0.12
----

2023-02-24

*Note, that this release introduces breaking changes!*

* Make it easy to use a different PDF library with "PdfFileProvider"
  by adding "pdf_generator_cls" and "pdf_generator_kwargs" optional
  arguments to the "pdf_file" method. Added "ReportlabPdfGenerator"
  class based on the famous "reportlab" library. Default is still
  "PdfkitPdfGenerator". Since "encoding" was something specific for
  "pdfkit" library, it was moved from "pdf_file" method to
  "PdfkitPdfGenerator", to which it can be passed in
  "pdf_generator_kwargs". If you have passed the "encoding" argument
  explicitly, make sure to make correspondent changes. Note, that
  using the new "ReportlabPdfGenerator" class could speed-up PDF
  generation by about 40 times.


0.11.5
------

2023-02-20

* Fixes in typing of "CsvFileProvider". "Tuple[str, str]" becomes
  "Tuple[str, ...]".


0.11.4
------

2023-02-16

Note:

  Release dedicated to my dear valentine - Anahit.

* Added "filename" to "data" property of values returned by
  "Mp3FileProvider" provider ("StringValue", "BytesValue").


0.11.3
------

2023-02-10

* Moved several interface classes from one location to another. If you
  haven't implemented custom generators, this won't affect you. If you
  did, make sure to update your imports:

     * "BaseTextAugmenter" has been moved from
       "faker_file.providers.augment_file_from_dir.augmenters.base" to
       "faker_file.providers.base.text_augmenter".

     * "BaseTextExtractor" has been moved from
       "faker_file.providers.augment_file_from_dir.extractors.base" to
       "faker_file.providers.base.text_extractor".

     * "BaseMp3Generator" has been moved from
       "faker_file.providers.mp3_file.generators.base" to
       "faker_file.providers.base.mp3_generator".


0.11.2
------

2023-02-07

* Add "filename" to "data" property of values returned by providers
  ("StringValue", "BytesValue").


0.11.1
------

2023-01-31

* Documentation improvements.

* MyPy fixes.


0.11
----

2023-01-25

* Allow returning binary contents of the file by providing the
  "raw=True" argument ("False" by default, works with all provider
  classes and inner functions). If you  have subclassed or overriden
  provider classes or written custom inner functions, make sure to
  reflect the changes in your code.


0.10.12
-------

2023-01-21

* Add "TarFileProvider" and "create_inner_tar_file" function.

* Add "OdpFileProvider" and "create_inner_odp_file" function.


0.10.11
-------

2023-01-20

* Improve "EPUB" document layout.

* Improve "PDF" document layout.

* Minor documentation improvements.


0.10.10
-------

2023-01-19

* Allow passing "model_name" and "action" arguments to the
  "ContextualWordEmbeddingsAugmenter".

* Replace "bert-base-cased" with "bert-base-multilingual-cased" as a
  default model for "ContextualWordEmbeddingsAugmenter".

* Improve "PPTX" document layout.

* Minor fixes in documentation.


0.10.9
------

2023-01-18

* Add an installation directive "[common]" to install everything
  except ML libraries.

* Added testing of UTF8 content.


0.10.8
------

2023-01-16

* Switch to PyPI releases of "gtts".

* Stop testing against Django 3.0 and 3.1.

* Documentation improvements.

* Tests improvements.


0.10.7
------

2023-01-13

* Add "OdtFileProvider" and "create_inner_odt_file" function.

* Documentation improvements.

* Async related deprecation fixes in "EdgeTtsMp3Generator".

* Optimize example factories.


0.10.6
------

2023-01-11

* Add "AugmentFileFromDirProvider" provider for making augmented
  copies of randomly picked files from given directory.

* Documentation improvements.

* Fixes in setup.


0.10.5
------

2023-01-09

* Add "fuzzy_choice_create_inner_file" inner function for easy
  diversion of files within archives ("ZIP", "EML").

* Documentation improvements.

* Add "MaryTTS" example (another MP3 generator for "Mp3FileProvider").


0.10.4
------

2023-01-08

* Add missing "mp3_generator_kwargs" argument to the
  "create_inner_mp3_file" function.

* Clean-up.


0.10.3
------

2023-01-07

Improvements of the "Mp3FileProvider" module:

* Pass active generator to the "Mp3FileProvider" in the "generator"
  argument if "BaseMp3Generator" (and all implementations).

* Introduce "handle_kwargs" method in the "BaseMp3Generator" to handle
  arbitrary provider specific tuning.

* Add "EdgeTtsMp3Generator" MP3 generator.

* Add "mp3_generator_kwargs" argument to the
  "Mp3FileProvider.mp3_file" method.


0.10.2
------

2023-01-06

* Add "Mp3FileProvider".

* Add "create_inner_mp3_file" inner function.


0.10.1
------

2023-01-05

* Fixes in "ZipFileProvider".


0.10
----

2023-01-04

*Note, that this release introduces breaking changes!*

* Move all "create_inner_*_file" functions from
  "faker_file.providers.zip_file" to
  "faker_file.providers.helpers.inner" module. Adjust your imports
  accordingly.

* Add "EmlFileProvider".

* Add "create_inner_eml_file" inner function.


0.9.3
-----

2023-01-03

* Add "EpubFileProvider" provider.


0.9.2
-----

2022-12-23

* Add "RrfFileProvider".

* Added "SQLAlchemy" factory example.


0.9.1
-----

2022-12-19

* Fixes in cloud storage.

* Documentation fixes.


0.9
---

2022-12-17

* Add optional "encoding" argument to "CsvFileProvider" and
  "PdfFileProvider" providers.

* Add "root_path" argument to cloud storages.

* Moved all image related code ("IcoFileProvider", "JpegFileProvider",
  "PngFileProvider", "SvgFileProvider", "WebpFileProvider") to
  "ImageMixin". Moved all tabular data related code
  ("OdsFileProvider", "XlsxFileProvider") to "TabularDataMixin".

* Documentation improvements.


0.8
---

2022-12-16

*Note, that this release introduces breaking changes!*

* All file system based operations are moved to a separate abstraction
  layer of file storages. The following storages have been
  implemented: "FileSystemStorage", "PathyFileSystemStorage",
  "AWSS3Storage", "GoogleCloudStorage" and "AzureStorage". The
  "root_path" and "rel_path" params of the providers are deprecated in
  favour of storages. See the docs more usage examples.


0.7
---

2022-12-12

* Added "RandomFileFromDirProvider" which picks a random file from
  directory given.

* Improved docs.


0.6
---

2022-12-11

* Pass optional "generator" argument to inner functions of the
  "ZipFileProvider".

* Added "create_inner_zip_file" inner function which allows to create
  nested ZIPs.

* Reached test coverage of 100%.


0.5
---

2022-12-10

*Note, that this release introduces breaking changes!*

* Added *ODS* file support.

* Switched to "tablib" for easy, non-variant support of various
  formats (*XLSX*, *ODS*).

* Silence "imgkit" logging output.

* *ZipFileProvider* allows to pass arbitrary arguments to inner
  functions. Put all your inner function arguments into a dictionary
  and pass it in *create_inner_file_args* key inside *options*
  argument. See the example below.

        zip_file = ZipFileProvider(None).file(
            prefix="zzz_archive_",
            options={
                "count": 5,
                "create_inner_file_func": create_inner_docx_file,
                "create_inner_file_args": {
                    "prefix": "zzz_file_",
                    "max_nb_chars": 1_024,
                    "content": "{{date}}\r\n{{text}}\r\n{{name}}",
                },
                "directory": "zzz",
            }
        )


0.4
---

2022-12-09

*Note, that this release introduces breaking changes!*

* Remove the concept of content generators (and the correspondent
  "content_generator" arguments in implemented providers). Instead,
  allow usage of dynamic fixtures in the provided "content" argument.

* Remove temporary files when creating ZIP archives.

* Various improvements and fixes in docs.


0.3
---

2022-12-08

* Add support for *BIN*, *CSV* and *XLSX* files.

* Better visual representation of generated images and PDFs.


0.2
---

2022-12-07

* Added support for *ICO*, *JPEG*, *PNG*, *SVG* and *WEBP* files.

* Documentation improvements.


0.1
---

2022-12-06

* Initial beta release.

======================================================================


Package
=======

* faker_file package

  * Subpackages

    * faker_file.cli package

      * Submodules

      * faker_file.cli.command module

        * "main()"

      * faker_file.cli.helpers module

        * "generate_completion_file()"

        * "generate_file()"

        * "get_method_kwargs()"

        * "is_optional_type()"

      * Module contents

    * faker_file.contrib package

      * Subpackages

        * faker_file.contrib.pdf_file package

          * Submodules

          * faker_file.contrib.pdf_file.pdfkit_snippets module

            * "add_h1_heading()"

            * "add_h2_heading()"

            * "add_h3_heading()"

            * "add_h4_heading()"

            * "add_h5_heading()"

            * "add_h6_heading()"

            * "add_heading()"

            * "add_page_break()"

            * "add_paragraph()"

            * "add_picture()"

            * "add_table()"

          * faker_file.contrib.pdf_file.reportlab_snippets module

            * "add_h1_heading()"

            * "add_h2_heading()"

            * "add_h3_heading()"

            * "add_h4_heading()"

            * "add_h5_heading()"

            * "add_h6_heading()"

            * "add_heading()"

            * "add_page_break()"

            * "add_paragraph()"

            * "add_picture()"

            * "add_table()"

          * Module contents

      * Submodules

      * faker_file.contrib.docx_file module

        * "add_h1_heading()"

        * "add_h2_heading()"

        * "add_h3_heading()"

        * "add_h4_heading()"

        * "add_h5_heading()"

        * "add_h6_heading()"

        * "add_heading()"

        * "add_page_break()"

        * "add_paragraph()"

        * "add_picture()"

        * "add_table()"

        * "add_title_heading()"

      * faker_file.contrib.odt_file module

        * "add_h1_heading()"

        * "add_h2_heading()"

        * "add_h3_heading()"

        * "add_h4_heading()"

        * "add_h5_heading()"

        * "add_h6_heading()"

        * "add_heading()"

        * "add_page_break()"

        * "add_paragraph()"

        * "add_picture()"

        * "add_table()"

      * Module contents

    * faker_file.providers package

      * Subpackages

        * faker_file.providers.augment_file_from_dir package

          * Subpackages

            * faker_file.providers.augment_file_from_dir.augmenters
              package

              * Submodules

              * faker_file.providers.augment_file_from_dir.augmenters
                .nlpaug_augmenter module

              * Module contents

            * faker_file.providers.augment_file_from_dir.extractors
              package

              * Submodules

              * faker_file.providers.augment_file_from_dir.extractors
                .tika_extractor module

              * Module contents

          * Module contents

            * "AugmentFileFromDirProvider"

              * "AugmentFileFromDirProvider.augment_file_from_dir()"

              * "AugmentFileFromDirProvider.extension"

        * faker_file.providers.base package

          * Submodules

          * faker_file.providers.base.image_generator module

            * "BaseImageGenerator"

              * "BaseImageGenerator.generate()"

              * "BaseImageGenerator.handle_kwargs()"

          * faker_file.providers.base.mp3_generator module

            * "BaseMp3Generator"

              * "BaseMp3Generator.content"

              * "BaseMp3Generator.generate()"

              * "BaseMp3Generator.generator"

              * "BaseMp3Generator.handle_kwargs()"

          * faker_file.providers.base.pdf_generator module

            * "BasePdfGenerator"

              * "BasePdfGenerator.generate()"

              * "BasePdfGenerator.handle_kwargs()"

          * faker_file.providers.base.text_augmenter module

            * "BaseTextAugmenter"

              * "BaseTextAugmenter.augment()"

              * "BaseTextAugmenter.handle_kwargs()"

          * faker_file.providers.base.text_extractor module

            * "BaseTextExtractor"

              * "BaseTextExtractor.extract()"

              * "BaseTextExtractor.handle_kwargs()"

              * "BaseTextExtractor.path"

          * Module contents

        * faker_file.providers.helpers package

          * Submodules

          * faker_file.providers.helpers.inner module

            * "create_inner_augment_image_from_path()"

            * "create_inner_augment_random_image_from_dir()"

            * "create_inner_bin_file()"

            * "create_inner_csv_file()"

            * "create_inner_docx_file()"

            * "create_inner_eml_file()"

            * "create_inner_epub_file()"

            * "create_inner_file_from_path()"

            * "create_inner_generic_file()"

            * "create_inner_graphic_ico_file()"

            * "create_inner_graphic_jpeg_file()"

            * "create_inner_graphic_pdf_file()"

            * "create_inner_graphic_png_file()"

            * "create_inner_graphic_webp_file()"

            * "create_inner_ico_file()"

            * "create_inner_jpeg_file()"

            * "create_inner_json_file()"

            * "create_inner_mp3_file()"

            * "create_inner_odp_file()"

            * "create_inner_ods_file()"

            * "create_inner_odt_file()"

            * "create_inner_pdf_file()"

            * "create_inner_png_file()"

            * "create_inner_pptx_file()"

            * "create_inner_random_file_from_dir()"

            * "create_inner_rtf_file()"

            * "create_inner_svg_file()"

            * "create_inner_tar_file()"

            * "create_inner_txt_file()"

            * "create_inner_webp_file()"

            * "create_inner_xlsx_file()"

            * "create_inner_xml_file()"

            * "create_inner_zip_file()"

            * "fuzzy_choice_create_inner_file()"

            * "list_create_inner_file()"

          * Module contents

        * faker_file.providers.image package

          * Submodules

          * faker_file.providers.image.augment module

            * "add_brightness()"

            * "add_contrast()"

            * "add_darkness()"

            * "add_saturation()"

            * "augment_image()"

            * "augment_image_file()"

            * "color_jitter()"

            * "decrease_contrast()"

            * "equalize()"

            * "flip_horizontal()"

            * "flip_vertical()"

            * "gaussian_blur()"

            * "grayscale()"

            * "random_crop()"

            * "resize_height()"

            * "resize_width()"

            * "rotate()"

            * "solarize()"

          * faker_file.providers.image.imgkit_generator module

            * "ImgkitImageGenerator"

              * "ImgkitImageGenerator.encoding"

              * "ImgkitImageGenerator.generate()"

              * "ImgkitImageGenerator.handle_kwargs()"

          * faker_file.providers.image.pil_generator module

            * "PilImageGenerator"

              * "PilImageGenerator.combine_images_vertically()"

              * "PilImageGenerator.create_image_instance()"

              * "PilImageGenerator.encoding"

              * "PilImageGenerator.find_max_fit_for_multi_line_text()"

              * "PilImageGenerator.find_max_fit_for_single_line_text(
                )"

              * "PilImageGenerator.font"

              * "PilImageGenerator.font_size"

              * "PilImageGenerator.generate()"

              * "PilImageGenerator.handle_kwargs()"

              * "PilImageGenerator.line_height"

              * "PilImageGenerator.page_height"

              * "PilImageGenerator.page_width"

              * "PilImageGenerator.save_and_start_new_page()"

              * "PilImageGenerator.spacing"

              * "PilImageGenerator.start_new_page()"

          * faker_file.providers.image.weasyprint_generator module

            * "WeasyPrintImageGenerator"

              * "WeasyPrintImageGenerator.create_image_instance()"

              * "WeasyPrintImageGenerator.encoding"

              * "WeasyPrintImageGenerator.generate()"

              * "WeasyPrintImageGenerator.handle_kwargs()"

              * "WeasyPrintImageGenerator.page_height"

              * "WeasyPrintImageGenerator.page_width"

              * "WeasyPrintImageGenerator.wrap()"

              * "WeasyPrintImageGenerator.wrapper_tag"

          * Module contents

        * faker_file.providers.mixins package

          * Submodules

          * faker_file.providers.mixins.graphic_image_mixin module

            * "GraphicImageMixin"

          * faker_file.providers.mixins.image_mixin module

            * "ImageMixin"

          * faker_file.providers.mixins.tablular_data_mixin module

            * "TabularDataMixin"

          * Module contents

        * faker_file.providers.mp3_file package

          * Subpackages

            * faker_file.providers.mp3_file.generators package

              * Submodules

              * faker_file.providers.mp3_file.generators.edge_tts_gen
                erator module

                * "EdgeTtsMp3Generator"

                  * "EdgeTtsMp3Generator.generate()"

                  * "EdgeTtsMp3Generator.handle_kwargs()"

                  * "EdgeTtsMp3Generator.voice"

              * faker_file.providers.mp3_file.generators.gtts_generat
                or module

                * "GttsMp3Generator"

                  * "GttsMp3Generator.generate()"

                  * "GttsMp3Generator.handle_kwargs()"

                  * "GttsMp3Generator.lang"

                  * "GttsMp3Generator.tld"

              * Module contents

          * Module contents

            * "Mp3FileProvider"

              * "Mp3FileProvider.extension"

              * "Mp3FileProvider.mp3_file()"

        * faker_file.providers.pdf_file package

          * Subpackages

            * faker_file.providers.pdf_file.generators package

              * Submodules

              * faker_file.providers.pdf_file.generators.pdfkit_gener
                ator module

                * "PdfkitPdfGenerator"

                  * "PdfkitPdfGenerator.encoding"

                  * "PdfkitPdfGenerator.generate()"

                  * "PdfkitPdfGenerator.handle_kwargs()"

              * faker_file.providers.pdf_file.generators.reportlab_ge
                nerator module

                * "ReportlabPdfGenerator"

                  * "ReportlabPdfGenerator.font_name"

                  * "ReportlabPdfGenerator.font_path"

                  * "ReportlabPdfGenerator.generate()"

                  * "ReportlabPdfGenerator.handle_kwargs()"

              * Module contents

          * Module contents

            * "GraphicPdfFileProvider"

              * "GraphicPdfFileProvider.extension"

              * "GraphicPdfFileProvider.graphic_pdf_file()"

              * "GraphicPdfFileProvider.image_format"

            * "PdfFileProvider"

              * "PdfFileProvider.extension"

              * "PdfFileProvider.pdf_file()"

      * Submodules

      * faker_file.providers.augment_image_from_path module

        * "AugmentImageFromPathProvider"

          * "AugmentImageFromPathProvider.augment_image_from_path()"

          * "AugmentImageFromPathProvider.extension"

      * faker_file.providers.augment_random_image_from_dir module

        * "AugmentRandomImageFromDirProvider"

          * "AugmentRandomImageFromDirProvider.augment_random_image_f
            rom_dir()"

          * "AugmentRandomImageFromDirProvider.extension"

      * faker_file.providers.bin_file module

        * "BinFileProvider"

          * "BinFileProvider.bin_file()"

          * "BinFileProvider.extension"

      * faker_file.providers.bmp_file module

        * "BmpFileProvider"

          * "BmpFileProvider.bmp_file()"

          * "BmpFileProvider.extension"

          * "BmpFileProvider.image_format"

        * "GraphicBmpFileProvider"

          * "GraphicBmpFileProvider.extension"

          * "GraphicBmpFileProvider.graphic_bmp_file()"

          * "GraphicBmpFileProvider.image_format"

      * faker_file.providers.csv_file module

        * "CsvFileProvider"

          * "CsvFileProvider.csv_file()"

          * "CsvFileProvider.extension"

      * faker_file.providers.docx_file module

        * "DocxFileProvider"

          * "DocxFileProvider.docx_file()"

          * "DocxFileProvider.extension"

      * faker_file.providers.eml_file module

        * "EmlFileProvider"

          * "EmlFileProvider.eml_file()"

          * "EmlFileProvider.extension"

      * faker_file.providers.epub_file module

        * "EpubFileProvider"

          * "EpubFileProvider.epub_file()"

          * "EpubFileProvider.extension"

      * faker_file.providers.file_from_path module

        * "FileFromPathProvider"

          * "FileFromPathProvider.extension"

          * "FileFromPathProvider.file_from_path()"

      * faker_file.providers.generic_file module

        * "GenericFileProvider"

          * "GenericFileProvider.extension"

          * "GenericFileProvider.generic_file()"

      * faker_file.providers.gif_file module

        * "GifFileProvider"

          * "GifFileProvider.extension"

          * "GifFileProvider.gif_file()"

          * "GifFileProvider.image_format"

        * "GraphicGifFileProvider"

          * "GraphicGifFileProvider.extension"

          * "GraphicGifFileProvider.graphic_gif_file()"

          * "GraphicGifFileProvider.image_format"

      * faker_file.providers.ico_file module

        * "GraphicIcoFileProvider"

          * "GraphicIcoFileProvider.extension"

          * "GraphicIcoFileProvider.graphic_ico_file()"

          * "GraphicIcoFileProvider.image_format"

        * "IcoFileProvider"

          * "IcoFileProvider.extension"

          * "IcoFileProvider.ico_file()"

          * "IcoFileProvider.image_format"

      * faker_file.providers.jpeg_file module

        * "GraphicJpegFileProvider"

          * "GraphicJpegFileProvider.extension"

          * "GraphicJpegFileProvider.graphic_jpeg_file()"

          * "GraphicJpegFileProvider.image_format"

        * "JpegFileProvider"

          * "JpegFileProvider.extension"

          * "JpegFileProvider.image_format"

          * "JpegFileProvider.jpeg_file()"

      * faker_file.providers.json_file module

        * "JsonFileProvider"

          * "JsonFileProvider.extension"

          * "JsonFileProvider.json_file()"

      * faker_file.providers.odp_file module

        * "OdpFileProvider"

          * "OdpFileProvider.extension"

          * "OdpFileProvider.odp_file()"

      * faker_file.providers.ods_file module

        * "OdsFileProvider"

          * "OdsFileProvider.extension"

          * "OdsFileProvider.ods_file()"

      * faker_file.providers.odt_file module

        * "OdtFileProvider"

          * "OdtFileProvider.extension"

          * "OdtFileProvider.odt_file()"

      * faker_file.providers.png_file module

        * "GraphicPngFileProvider"

          * "GraphicPngFileProvider.extension"

          * "GraphicPngFileProvider.graphic_png_file()"

          * "GraphicPngFileProvider.image_format"

        * "PngFileProvider"

          * "PngFileProvider.extension"

          * "PngFileProvider.image_format"

          * "PngFileProvider.png_file()"

      * faker_file.providers.pptx_file module

        * "PptxFileProvider"

          * "PptxFileProvider.extension"

          * "PptxFileProvider.pptx_file()"

      * faker_file.providers.random_file_from_dir module

        * "RandomFileFromDirProvider"

          * "RandomFileFromDirProvider.extension"

          * "RandomFileFromDirProvider.random_file_from_dir()"

      * faker_file.providers.rtf_file module

        * "RtfFileProvider"

          * "RtfFileProvider.extension"

          * "RtfFileProvider.rtf_file()"

      * faker_file.providers.svg_file module

        * "SvgFileProvider"

          * "SvgFileProvider.extension"

          * "SvgFileProvider.image_format"

          * "SvgFileProvider.svg_file()"

      * faker_file.providers.tar_file module

        * "TarFileProvider"

          * "TarFileProvider.extension"

          * "TarFileProvider.tar_file()"

      * faker_file.providers.tiff_file module

        * "GraphicTiffFileProvider"

          * "GraphicTiffFileProvider.extension"

          * "GraphicTiffFileProvider.graphic_tiff_file()"

          * "GraphicTiffFileProvider.image_format"

        * "TiffFileProvider"

          * "TiffFileProvider.extension"

          * "TiffFileProvider.image_format"

          * "TiffFileProvider.tiff_file()"

      * faker_file.providers.txt_file module

        * "TxtFileProvider"

          * "TxtFileProvider.extension"

          * "TxtFileProvider.txt_file()"

      * faker_file.providers.webp_file module

        * "GraphicWebpFileProvider"

          * "GraphicWebpFileProvider.extension"

          * "GraphicWebpFileProvider.graphic_webp_file()"

          * "GraphicWebpFileProvider.image_format"

        * "WebpFileProvider"

          * "WebpFileProvider.extension"

          * "WebpFileProvider.image_format"

          * "WebpFileProvider.webp_file()"

      * faker_file.providers.xlsx_file module

        * "XlsxFileProvider"

          * "XlsxFileProvider.extension"

          * "XlsxFileProvider.xlsx_file()"

      * faker_file.providers.xml_file module

        * "XmlFileProvider"

          * "XmlFileProvider.extension"

          * "XmlFileProvider.xml_file()"

      * faker_file.providers.zip_file module

        * "ZipFileProvider"

          * "ZipFileProvider.extension"

          * "ZipFileProvider.zip_file()"

      * Module contents

    * faker_file.storages package

      * Submodules

      * faker_file.storages.aws_s3 module

      * faker_file.storages.azure_cloud_storage module

      * faker_file.storages.base module

        * "BaseStorage"

          * "BaseStorage.abspath()"

          * "BaseStorage.exists()"

          * "BaseStorage.generate_basename()"

          * "BaseStorage.generate_filename()"

          * "BaseStorage.relpath()"

          * "BaseStorage.unlink()"

          * "BaseStorage.write_bytes()"

          * "BaseStorage.write_text()"

      * faker_file.storages.cloud module

      * faker_file.storages.filesystem module

        * "FileSystemStorage"

          * "FileSystemStorage.abspath()"

          * "FileSystemStorage.exists()"

          * "FileSystemStorage.generate_filename()"

          * "FileSystemStorage.relpath()"

          * "FileSystemStorage.unlink()"

          * "FileSystemStorage.write_bytes()"

          * "FileSystemStorage.write_text()"

      * faker_file.storages.google_cloud_storage module

      * faker_file.storages.sftp_storage module

        * "SFTPStorage"

          * "SFTPStorage.abspath()"

          * "SFTPStorage.close()"

          * "SFTPStorage.exists()"

          * "SFTPStorage.generate_filename()"

          * "SFTPStorage.relpath()"

          * "SFTPStorage.sftp"

          * "SFTPStorage.transport"

          * "SFTPStorage.unlink()"

          * "SFTPStorage.write_bytes()"

          * "SFTPStorage.write_text()"

      * Module contents

    * faker_file.tests package

      * Submodules

      * faker_file.tests.data module

      * faker_file.tests.sftp_server module

        * "SFTPServer"

        * "SFTPServerManager"

          * "SFTPServerManager.start()"

          * "SFTPServerManager.start_server()"

          * "SFTPServerManager.stop()"

        * "SSHServer"

          * "SSHServer.auth_completed()"

          * "SSHServer.begin_auth()"

          * "SSHServer.password_auth_supported()"

          * "SSHServer.session_requested()"

          * "SSHServer.sftp_requested()"

          * "SSHServer.validate_password()"

        * "start_server()"

        * "start_server_async()"

      * faker_file.tests.test_augment module

      * faker_file.tests.test_augment_file_from_dir_provider module

      * faker_file.tests.test_base module

        * "StringListTestCase"

          * "StringListTestCase.test_string_list()"

      * faker_file.tests.test_cli module

      * faker_file.tests.test_data_integrity module

      * faker_file.tests.test_django_integration module

      * faker_file.tests.test_helpers module

      * faker_file.tests.test_providers module

      * faker_file.tests.test_registry module

      * faker_file.tests.test_sftp_server module

      * faker_file.tests.test_sftp_storage module

      * faker_file.tests.test_sqlalchemy_integration module

      * faker_file.tests.test_storages module

      * faker_file.tests.texts module

      * faker_file.tests.utils module

        * "AutoFreePortInt"

          * "AutoFreePortInt.DEFAULT_MAX_PORT"

          * "AutoFreePortInt.DEFAULT_MIN_PORT"

        * "AutoIncPortInt"

      * Module contents

  * Submodules

  * faker_file.base module

    * "BytesValue"

      * "BytesValue.data"

    * "DEFAULT_FORMAT_FUNC()"

    * "DynamicTemplate"

    * "FileMixin"

      * "FileMixin.extension"

      * "FileMixin.formats"

      * "FileMixin.generator"

      * "FileMixin.numerify"

      * "FileMixin.random_element"

    * "StringList"

      * "StringList.add_string()"

      * "StringList.remove_string()"

    * "StringValue"

      * "StringValue.data"

    * "parse_format_func()"

    * "pystr_format_func()"

    * "returns_list()"

  * faker_file.constants module

  * faker_file.helpers module

    * "get_mime_maintype_subtype()"

    * "load_class_from_path()"

    * "random_pop()"

    * "wrap_text()"

  * faker_file.registry module

    * "FileRegistry"

      * "FileRegistry.add()"

      * "FileRegistry.clean_up()"

      * "FileRegistry.remove()"

      * "FileRegistry.search()"

  * Module contents


Indices and tables
==================

* Index

* Module Index

* Search Page
